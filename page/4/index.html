<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="geekymv">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="geekymv">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="geekymv">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>geekymv</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">geekymv</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/git-branch/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/git-branch/" itemprop="url">git-branch</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T16:45:11+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Git 的分支模型可以称为它的”必杀技特性“，Git 鼓励在工作中要频繁的使用分支与合并，<br>Git 创建新分支几乎可以在瞬间完成，在不同的分支之间切换的速度也是非常快。</p>
<p>我们在进行提交操作时，Git 会保存一个提交对象(commit object)，该提交对象包含我们在之前配置的user.name、user.email、<br>提交说明和指向它的父对象的指针。第一次提交对象没有父对象，普通提交对象有一个父对象，由多个分支合并产生的提交对象有多个父对象。</p>
<h4 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h4><p>Git 的默认分支名字是<code>master</code>。Git的<code>master</code> 并不是一个特殊的分支，它跟其他的分支并没有什么区别，<br>只是<code>master</code> 分支是<code>git init</code> 命令默认创建的分支名称。</p>
<p>都目前为止，我们一直在master分支上提交，此时master分支指向最后那个提交对象。<br><img src="/2019/05/29/git-branch/git-master.png" title="git branch"></p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>创建名字为dev 的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br></pre></td></tr></table></figure></p>
<p>会在当前所在的提交对象上创建一个指针。<br><img src="/2019/05/29/git-branch/git-branch.png" title="git branch"></p>
<p>在Git 中HEAD 指针指向当前所在的分支，通过上图可以看到HEAD 指向了master 分支。</p>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>通过<code>git branch</code> 仅仅是创建了dev 分支，并不会自动切换到分支中，<br>要切换到一个已存在的分支，可以使用<code>git checkout</code> 命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure></p>
<p>这个时候HEAD 指针就指向dev了。<br><img src="/2019/05/29/git-branch/git-dev.png" title="git branch"></p>
<p>查看分支 git branch 命令后面不带任何参数，前面带*号的分支是当前所在分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p>
<p>可以看到当前所在的是 dev 分支。</p>
<p>现在想要切回到master 分支，可以使用<code>git checkout master</code> 或 <code>git checkout -</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h4><p>有时候我们想要创建一个分支并立即切换到新的分支上工作，Git 也提供了一个简单的方式实现创建并切换到某个分支，<br>使用 <code>git checkout -b branch_name</code> 命令（合并了上面两个命令）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b test</span><br><span class="line">Switched to a new branch &apos;test&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>大多数情况下，在一个项目中的master 分支一般用于发布生产环境，dev 分支属于开发分支，<br>比如我们现在在dev 分支开发了一个小功能，并测试完毕。那么我们需要将dev分支合并到master分支，然后将新功能发布到生产环境。<br>开发过程如下：<br>我们在dev 分支下新添加一个 world.txt 文件，作为新功能的演示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim world.txt</span><br><span class="line">hi,我是新功能</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>添加到暂存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add world.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add world.txt&quot; </span><br><span class="line">[dev ef8a2b0] add world.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 world.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>提交完毕，此时我们的dev 分支向前移动（指针右移）了，但是master 分支却没有，<br>它仍然指向执行<code>git checkout dev</code> 时所指的对象，如下图所示：<br><img src="/2019/05/29/git-branch/git-dev-commit.png" title="git branch"></p>
<p>新功能开发并测试完毕，需要将dev 分支内容合并的到master 分支，首先要切换到master分支，<br>然后使用git merge dev 将dev分支合并到master分支。</p>
<ul>
<li>切换到master 分支<br>如果dev 分支的工作目录和暂存区还有未提交的内容，它可能会和你即将切换到到master ß分支产生冲突从而阻止Git 切换到该分支，<br>最好的办法是在你切换分支之前，保证当前分支是一个干净到状态，当然Git 也提供了一些方法绕过这个问题，我们在后面会介绍。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>
<p>这个命令做了两件事，第一个是HEAD 指回了master 分支，第二个是将工作目录恢复成master 分支所指向的内容。<br>也就是说，在切换到一个分支时，我们的工作目录的文件会改变成该分支的内容。</p>
<ul>
<li>执行合并操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 69da26e..ef8a2b0</span><br><span class="line">Fast-forward</span><br><span class="line"> world.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 world.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>你可能已经注意到了<code>Fast-forward</code> 快进这个词，由于master 分支所指向的提交是dev 分支的直接父对象，<br>Git 只是简单的将指针向前移动，所以合并速度非常快。当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会介绍其他方式到合并。<br><img src="/2019/05/29/git-branch/git-merge-finished.png" title="git merge"></p>
<ul>
<li>查看master 分支上是否有world.txt 文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">hello.txt world.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，合并操作完成。合并过程中，如果有Git处理不了的冲突，还需要开发人员手动合并，决定冲突的代码需要保留的部分。</p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>合并完成后，就可以放心的删除dev 分支了。注意删除分支的时候，不能删除当前所在的分支，需要先切换到别的分支上去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure></p>
<p>git branch -D branch_name 强制删除</p>
<p>删除dev 分支后，查看分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>此时，只剩下master 分支了。<br>因为在Git 中创建、合并和删除分支都非常快，所以Git 鼓励我们使用分支完成某个任务，合并后再删除分支，<br>这和直接在master 分支上工作效果上一样的，但过程更安全。</p>
<p>本章小结：<br>创建分支 <code>git branch branch_name</code><br>切换分支 <code>git checkout branch_name</code><br>查看分支 <code>git branch</code><br>创建并切换分支 <code>git checkout -b branch_name</code><br>合并某分支到当前分支 <code>git merge branch_name</code><br>删除分支 <code>git branch -d branch_name</code> 或 <code>git branch -D branch_name</code> 强制删除</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/git-command/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/git-command/" itemprop="url">git-command</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T08:56:27+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>配置并初始化一个仓库（repository）<br>开始或听着跟踪（track）文件<br>暂存（stage）或提交（commit）更改<br>配置Git来忽略指定的文件和文件模式<br>撤销错误操作<br>浏览历史版本以及不同提交间的差异<br>向远程仓库推送（push）<br>从远程仓库拉取（pull）文件</p>
<h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>创建目录mygit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mygit</span><br></pre></td></tr></table></figure></p>
<p>进入mygit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd mygit</span><br></pre></td></tr></table></figure></p>
<p>仓库初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p>
<p>Windows 系统下，通过Git Bash 操作如下：<br><img src="/2019/05/29/git-command/git-init-win.png" title="git init"></p>
<p>Mac 下，通过 Terminal 操作如下：<br><img src="/2019/05/29/git-command/git-init-mac.png" title="git init"></p>
<p>当执行完<code>git init</code> 命令后，可以看到控制台多出了<code>(master)</code>的标识，<br>它表示当前是在master分支，这也是 Git 为我们创建的默认分支（后面会详细介绍 Git 分支）。</p>
<p>使用<code>ls -al</code> 命令查看<code>git init</code> 命令为我们生成了哪些隐藏文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/ls-al-git.png" title="ls-al-git">
<p>可以看到，mygit 目录下多出了.git 目录，这个子目录包含初始化的 Git 仓库所有必须的文件，<br>比如有我们在上一篇文章中介绍的关于git config –local配置方式中提到的config文件。<br><img src="/2019/05/29/git-command/git-config.png" title="git config"><br>一般我们不会直接修改这个文件，而是通过Git 提供的命令去操作。</p>
<p>查看工作目录状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-status.png" title="git status">
<p><code>git status</code> 命令将会成为以后经常会使用的命令，用来查看工作目录文件的状态，以便决定下一步的操作。</p>
<p>现在我们可以创建一个文件，然后使用<code>git add</code> 命令来实现对文件对追踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello.txt</span><br></pre></td></tr></table></figure></p>
<p>编辑文件，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hello.txt</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Git</span><br></pre></td></tr></table></figure>
<p>查看工作目录状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-status-2.png" title="git status">
<p>在状态报告中可以看到，当前在 master 分支，hello.txt 文件未被跟踪，<br>我们可以使用 <code>git add</code> 命令来实现对文件的跟踪。</p>
<p>开始跟踪hello.txt文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.txt</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-add.png" title="git add">
<p>控制台没有任何信息输出（Linux/Unix系统的设计思想：没有消息就是最好的消息）<br>也可以使用<code>git add .</code> 命令对当前目录下所有文件进行跟踪。</p>
<p>查看状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-status-3.png" title="git status">
<p>可以看到，hello.txt文件已被跟踪，并处于暂存状态，只要在<code>Changes to be committed:</code>这行下面的，就说明是已暂存状态。<br>对于已暂存的文件，我们可以将hello.txt文件从暂存区回退到工作区，也可以提交hello.txt文件。</p>
<p>这里我们先演示从暂存区回退到工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached hello.txt</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-rm-cached.png" title="git rm --cached">
<p>查看状态，发现和刚创建完文件时一样。</p>
<p>接下来，我们重新将hello.txt 文件添加到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.txt</span><br></pre></td></tr></table></figure></p>
<p>提交到版本库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure></p>
<p>输入<code>git commit</code>直接回车，默认会调用本机文本编辑器，需要输入提交信息，我们输入commit hello.txt信息，保存，关闭文件。</p>
<p>Windows 系统下，通过Git Bash 操作如下：<br><img src="/2019/05/29/git-command/git-commit-win.png" title="git commit"></p>
<p>Mac 下，通过 Terminal 操作如下：<br><img src="/2019/05/29/git-command/git-commit-mac.png" title="git commit"></p>
<p>此时，hello.txt文件已成功提交，可以看到如下信息：<br><img src="/2019/05/29/git-command/git-commit.png" title="git commit"></p>
<p>一般情况下，我们输入的提交信息都不会特别多，这时我们可以使用 <code>git commit -m &quot;提交信息&quot;</code>。</p>
<p>查看工作区状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>说明现在的工作目录很干净。换句话说，就是当前目录下没有出现任何未跟踪状态的新文件，<br>并且所有已跟踪文件在上次提交后都没有被修改过，否则Git 会在这里列出来。</p>
<p>查看提交日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-log.png" title="git log">
<p>默认不加任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。<br>git log 命令会列出每个提交的SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<h4 id="暂存修改的文件"><a href="#暂存修改的文件" class="headerlink" title="暂存修改的文件"></a>暂存修改的文件</h4><p>修改hello.txt 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi hello.txt</span><br></pre></td></tr></table></figure></p>
<p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello Git</span><br><span class="line">hello Java</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-status-4.png" title="git status">
<p>出现在<code>Changes not staged for commit</code> 这行下面，说明修改了已跟踪的文件，但还没有放到暂存区。<br>要暂存这次更新，需要运行<code>git add</code>命令。或者使用<code>git checkout</code> 命令将工作区的文件撤销修改。<br><code>git add</code> 是个多功能的命令：</p>
<ul>
<li>用于开始跟踪新文件；</li>
<li>把已跟踪的文件放到暂存区；</li>
<li>用于把有冲突的文件标记为已解决状态（这个后面会用到）。 </li>
</ul>
<p>我们先演示下使用<code>git checkout</code> 命令撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- hello.txt</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-checkout.png" title="git checkout">
<p>可以看到hello.txt文件中添加的一行文本（hello Java）被撤销。</p>
<p>我们按照上面的方式再修改hello.txt文件，演示将修改添加到暂存取的功能<br>运行<code>git add</code> 命令将已修改的hello.txt 文件放到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.txt</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-add-2.png" title="git add">
<p>通过<code>git status</code> 可以看到hello.txt文件的修改已暂存。</p>
<h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><p><code>git status</code> 命令的输出十分详细，使用 <code>git status -s</code> 或 <code>git status --short</code> 命令可以得到更为紧凑的格式输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure></p>
<p>新添加的未跟踪文件前面有 ?? 标记</p>
<p>新添加到暂存区的文件前面有 A 标记</p>
<p>修改过的文件前面有 M 标记，注意M有两个可以出现的位置，<br>出现在右边的M表示该文件被修改了但还没有放到暂存区，出现在左边的 M 表示该文件被修改并放入了暂存区。</p>
<h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>git diff 不加任何参数比较工作目录中的当前文件和暂存区之间的差异<br>git diff HEAD 比较工作区与最新本地版本库<br>git diff commit-id 比较工作区与指定 commit-id 之间的差异</p>
<p>git diff –cached 比较暂存区与最新本地版本库<br>git diff –cached commit-id 比较暂存区与指定commit-id 之间差异</p>
<h4 id="提交时跳过使用暂存区"><a href="#提交时跳过使用暂存区" class="headerlink" title="提交时跳过使用暂存区"></a>提交时跳过使用暂存区</h4><p>git commit 使用暂存区可以精心准备要提交的内容，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区的方式，<br>在提交的时候给git commit 加上-a 选项，Git会自动把所有已跟踪过的文件暂存起来一并提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &apos;提交说明&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm hello.txt</span><br><span class="line">git commit -m &apos;提交说明&apos;</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-rm-1.png" title="git rm">
<p>大部分情况下，我们会直接在文件管理器中把文件删除了或者使用rm 命令删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm hello.txt</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<img src="/2019/05/29/git-command/git-rm.png" title="git rm">
<p>有两个选择:<br>1.确实要从版本库中删除该文件，就用git rm 记录此次删除文件的操作，并用git commit。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm hello.txt</span><br><span class="line">git commit -m &apos;提交说明&apos;</span><br></pre></td></tr></table></figure></p>
<p>现在文件就从版本库中删除了。</p>
<p>2.删错了，把误删的文件恢复到最新版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- hello.txt</span><br></pre></td></tr></table></figure></p>
<p>用版本库里的版本替换工作区的版本，可能会丢失最近一次提交后你修改的内容。</p>
<p>想把文件从Git仓库中删除，但是仍希望保留到当前工作目录中，<br>git rm –cached hello.txt</p>
<h4 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h4><p>在我们日常开发中，可能会出现修改文件名的情况，比如觉得某个类的名字取的不能够见名知义，想要修改。<br>要在Git 中对文件重命名，可以使用<code>git mv</code> 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure></p>
<p>比如，我们将文件 hello.txt 改名为hello2.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv hello.txt hello2.txt</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-mv.png" title="git mv">
<p>查看状态信息，可以看到 Git 能够识别到我们对文件执行了重命名操作，并且已是暂存状态。<br>运行git mv 相当与运行了下面三条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv hello.txt hello2.txt</span><br><span class="line">$ git rm hello.txt</span><br><span class="line">$ git add hello2.txt</span><br></pre></td></tr></table></figure></p>
<p>重命名已完成，这个时候我们可以提交修改 <code>git commit -m &quot;重命名文件&quot;</code>。<br>或者误操作了这个文件，想要回退。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD hello2.txt</span><br></pre></td></tr></table></figure></p>
<img src="/2019/05/29/git-command/git-reset.png" title="git reset">
<p>这样hello2.txt 文件处于未跟踪状态了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD hello.txt</span><br></pre></td></tr></table></figure>
<img src="/2019/05/29/git-command/git-reset-2.png" title="git reset">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- hello.txt</span><br><span class="line">$ rm hello2.txt</span><br></pre></td></tr></table></figure>
<img src="/2019/05/29/git-command/git-checkout-2.png" title="git checkout">
<h4 id="文件撤销"><a href="#文件撤销" class="headerlink" title="文件撤销"></a>文件撤销</h4><p>在日常开发的过程中，我们可能会遇到以下几种的场景：<br>场景一：<br>在工作区修改了文件内容，还没添加到暂存区，发现修改错了想要撤销修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat hello.txt</span><br><span class="line">hello Git</span><br></pre></td></tr></table></figure></p>
<p>修改hello.txt 文件，添加一行内容hello world<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.txt</span><br><span class="line">hello Git</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>使用<code>git checkout -- &lt;file&gt;...</code> 撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- hello.txt</span><br></pre></td></tr></table></figure></p>
<p>查看状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>查看hello.txt 文件内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat hello.txt</span><br><span class="line">hello Git</span><br></pre></td></tr></table></figure></p>
<p>hello.txt 文件回到和版本库一样。</p>
<p>场景二：<br>与场景一一样在工作区修改了文件内容，不同的是这个时候被修改的 hello.txt 文件已经添加到暂存区了，需要撤销修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.txt</span><br><span class="line">hello Git</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>查看状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>将修改的文件添加到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.txt</span><br></pre></td></tr></table></figure></p>
<p>查看状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br></pre></td></tr></table></figure></p>
<p>现在我们首先将文件从暂存区回退到工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD hello.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       hello.txt</span><br></pre></td></tr></table></figure></p>
<p>查看状态，此时和场景一的状态是一样的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>git checkout -- &lt;file&gt;...</code> 撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- hello.txt</span><br></pre></td></tr></table></figure></p>
<p>场景三：<br>与场景二一样在工作区修改了文件内容，被修改的 hello.txt 文件已经添加到暂存区了，这个时候在工作区又做了修改，需要撤销本次修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.txt </span><br><span class="line">hello Git</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>将修改的文件添加到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.txt</span><br></pre></td></tr></table></figure></p>
<p>再次编辑文件，添加新的一行内容hello Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.txt </span><br><span class="line">hello Git</span><br><span class="line">hello world</span><br><span class="line">hello Java</span><br></pre></td></tr></table></figure></p>
<p>查看状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br></pre></td></tr></table></figure></p>
<p>此时，hello.txt 文件同时出现在暂存区和非暂存区。<br>我们想要撤销本次的修改，那么只要执行<code>git checkout -- hello.txt</code> 就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout hello.txt</span><br><span class="line">Updated 1 path from the index</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br></pre></td></tr></table></figure>
<p>查看文件内容，本次修改已经撤销了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat hello.txt</span><br><span class="line">hello Git</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<h4 id="文件撤销小结"><a href="#文件撤销小结" class="headerlink" title="文件撤销小结"></a>文件撤销小结</h4><p>如果hello.txt 修改后，还没有添加到暂存区，现在想要撤销，执行<code>git checkout -- hello.txt</code> 则回到和版本库一样的状态。<br>如果hello.txt 已经添加到暂存区，又做了修改，现在想要撤销本次修改，执行<code>git checkout -- hello.txt</code> ，撤销的是工作目录的修改，则回到和暂存区一样的状态。<br>当然如果是一个新的文件还没有添加到暂存区，也就没有Git撤销操作了。总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<p>场景四：<br>这个时候终于把hello.txt 文件修改完了，愉快的执行了提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;fix bug #666&quot;</span><br><span class="line">[master 50b27fc] fix bug #666</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>提交完后发现bug号写错了，其实修改的是bug #66，想要修改提交说明。</p>
<p>查看提交说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">commit 50b27fce9b19dd25736893bcc3bb49c46a1242ae (HEAD -&gt; master)</span><br><span class="line">Author: geekymv &lt;ym2011678@foxmail.com&gt;</span><br><span class="line">Date:   Thu Jun 13 19:22:14 2019 +0800</span><br><span class="line"></span><br><span class="line">    fix bug #666</span><br></pre></td></tr></table></figure></p>
<p>修改最近一次的提交说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m &quot;fix bug #66&quot;</span><br><span class="line"></span><br><span class="line">[master 5c10da1] fix bug #66</span><br><span class="line"> Date: Thu Jun 13 19:22:14 2019 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">commit 5c10da1d45b53cf2f98c538b9f8d758ff961fd81 (HEAD -&gt; master)</span><br><span class="line">Author: geekymv &lt;ym2011678@foxmail.com&gt;</span><br><span class="line">Date:   Thu Jun 13 19:22:14 2019 +0800</span><br><span class="line"></span><br><span class="line">    fix bug #66</span><br></pre></td></tr></table></figure>
<p>已经成功修改了提交说明，并没有新增commit id。</p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 5c10da1d45b53cf2f98c538b9f8d758ff961fd81 (HEAD -&gt; master)</span><br><span class="line">Author: geekymv &lt;ym2011678@foxmail.com&gt;</span><br><span class="line">Date:   Thu Jun 13 19:22:14 2019 +0800</span><br><span class="line"></span><br><span class="line">    fix bug #66</span><br><span class="line"></span><br><span class="line">commit 29cf508b469fd4b89de66b8b979e14b10c2663ea</span><br><span class="line">Author: geekymv &lt;ym2011678@foxmail.com&gt;</span><br><span class="line">Date:   Thu Jun 13 18:55:47 2019 +0800</span><br><span class="line"></span><br><span class="line">    修改文件</span><br><span class="line"></span><br><span class="line">commit 0a49afaf82d809568ecc942baf4c170d5027ef6d</span><br><span class="line">Author: geekymv &lt;ym2011678@foxmail.com&gt;</span><br><span class="line">Date:   Wed Jun 5 21:03:17 2019 +0800</span><br><span class="line"></span><br><span class="line">    add</span><br></pre></td></tr></table></figure>
<p>git log 命令显示从最近到最远的提交说明，如果觉得输出的信息太多，可以加上参数<code>--pretty=oneline</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">5c10da1d45b53cf2f98c538b9f8d758ff961fd81 (HEAD -&gt; master) fix bug #66</span><br><span class="line">29cf508b469fd4b89de66b8b979e14b10c2663ea 修改文件</span><br><span class="line">0a49afaf82d809568ecc942baf4c170d5027ef6d add</span><br></pre></td></tr></table></figure></p>
<p>这下清爽多了！</p>
<p>在Git中，用HEAD表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，<br>当然往上10个版本写10个^比较容易数不过来，所以写成HEAD~10。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 29cf508 修改文件</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">29cf508b469fd4b89de66b8b979e14b10c2663ea (HEAD -&gt; master) 修改文件</span><br><span class="line">0a49afaf82d809568ecc942baf4c170d5027ef6d add</span><br></pre></td></tr></table></figure>
<p>可以看到当前版本是<code>29cf50...</code>。</p>
<p>现在要想还回到指定回到<code>5c10da1d45b53cf2f98c538b9f8d758ff961fd81</code>版本，<br>当然版本号没必要写全，前几位就可以了，Git会自动去找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 5c10da</span><br><span class="line">HEAD is now at 5c10da1 fix bug #66</span><br></pre></td></tr></table></figure>
<p>可以看到又回到了<code>5c10da...</code>版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">5c10da1d45b53cf2f98c538b9f8d758ff961fd81 (HEAD -&gt; master) fix bug #66</span><br><span class="line">29cf508b469fd4b89de66b8b979e14b10c2663ea 修改文件</span><br><span class="line">0a49afaf82d809568ecc942baf4c170d5027ef6d add</span><br></pre></td></tr></table></figure></p>
<p>当你用<code>$ git reset --hard HEAD^</code>命令回退到<code>29cf50...</code>版本时，再想恢复到最新版本怎么版呢？<br>上面我们能恢复是因为我们在笔记中记录了 commit id。这个时候使用<code>git log</code> 已经看不到最新版本到commit id 了。<br>不用担心，在Git中总是有后悔药可以吃，<code>git reflog</code>记录你的每一次命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">29cf508 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 29cf</span><br><span class="line">5c10da1 HEAD@&#123;1&#125;: reset: moving to 5c10da1d45b53cf2f98c538b9f8d758ff961fd81</span><br><span class="line">29cf508 (HEAD -&gt; master) HEAD@&#123;2&#125;: reset: moving to HEAD^</span><br><span class="line">5c10da1 HEAD@&#123;3&#125;: commit (amend): fix bug #66</span><br><span class="line">50b27fc HEAD@&#123;4&#125;: commit: fix bug #666</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/git-install/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/27/git-install/" itemprop="url">git-install</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-27T09:05:04+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><ul>
<li>在Linux上安装</li>
<li><p>Debian / Ubuntu</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>CentOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>Fedora</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git-core</span><br></pre></td></tr></table></figure>
</li>
<li><p>Arch Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -Sy git</span><br></pre></td></tr></table></figure>
</li>
<li><p>Gentoo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo emerge --ask --verbose dev-vcs/git</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Mac OS X 上安装<br>在Mac上，这里推荐使用Homebrew 安装，具体方法请参考Homebrew 的文档：<a href="http://brew.sh。" target="_blank" rel="noopener">http://brew.sh。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Windows上安装<br>官方版本可以在 Git 官方网站（<a href="https://git-scm.com/）下载。" target="_blank" rel="noopener">https://git-scm.com/）下载。</a></p>
<img src="/2019/05/27/git-install/git-win-download.png" title="git-win-download">
</li>
</ul>
<p>1.点击<code>Download 2.21.0 for Windows</code>下载会自动开始，下载完成得到<code>Git-2.21.0-64-bit.exe</code> 可执行文件，<br>可能下载的很慢或者下载不了，不过不用担心我已经帮你下好了（通过公众号回复关键字”Git安装包”获取）。</p>
<p>2.然后按默认选项安装即可。安装完成后，在开始菜单里找到Git-&gt;Git Bash，弹出一个类似命令行窗口，就说明Git安装成功！<br><img src="/2019/05/27/git-install/git-install-win-13.png" title="git-install-win"></p>
<p>使用<code>git --version</code> 命令查看Git版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.21.0.windows.1</span><br></pre></td></tr></table></figure></p>
<p>查看Git的安装目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ which git</span><br><span class="line">/mingw64/bin/git</span><br></pre></td></tr></table></figure></p>
<p>更多安装方法可以参考官网教程（<a href="https://git-scm.com/book/zh/v2/起步-安装-Git）" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/起步-安装-Git）</a></p>
<h4 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h4><p>Git自带一个 git config 的工具，专门用来配置或读取相应的工作环境变量。这些变量可以存储在三个不同的位置：</p>
<ul>
<li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置，使用 git config –system 配置；（几乎不会使用）</li>
<li>~/.gitconfig 文件：只针对当前用户，使用 git config –global 配置；（最常用的方式）</li>
<li>针对于特定项目的.git/config 文件中，使用 git config –local 配置；（可以在不同的项目使用不同的配置）</li>
</ul>
<p>优先级：local &gt; global &gt; system</p>
<p>设置user.name 和 user.email<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &apos;geekymv&apos;</span><br><span class="line">$ git config --global user.email &apos;ym2011678@foxmail.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>查看user.name配置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br></pre></td></tr></table></figure></p>
<p>查看user.email配置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.email</span><br></pre></td></tr></table></figure></p>
<p>查看所有配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></p>
<h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如，要想获得 config 命令的手册，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git help config</span><br></pre></td></tr></table></figure></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本文主要介绍了Git 在Linux、Mac OS X 和 Windows 系统上的安装方法，Git 配置及如何获取 Git 命令的使用手册，下一篇文章会介绍 Git仓库和 Git基本命令的使用。</p>
<p>「更多精彩内容请关注公众号geekymv，喜欢请分享给更多的朋友哦」</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/vi/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/vi/" itemprop="url">vi</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T21:30:20+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>shift + a 进入一行的末尾</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/git/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/git/" itemprop="url">git</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T20:20:18+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>还记得前段时间的热门话题<a href="https://996.icu" target="_blank" rel="noopener">996.ICU</a>么？<br>作为程序员的你，深恶痛绝996的你，当然要给个star。<br><img src="/2019/05/21/git/996.icu.png" title="996.icu"><br>当你点击star的时候，你会发现网页跳转到了996.ICU在 GitHub的主页，作为程序员的你如果还不知道GitHub是什么真的是有点out了！<br><img src="/2019/05/21/git/996.icu-star.png" title="996.icu.star"><br>GitHub 是什么呢，我们有必要先了解下Git。</p>
<h4 id="Git-是什么？"><a href="#Git-是什么？" class="headerlink" title="Git 是什么？"></a>Git 是什么？</h4><p>Git 是一款开源免费的分布式版本控制系统。<br>Git 官网 <a href="https://git-scm.com，下面一段话摘自Git" target="_blank" rel="noopener">https://git-scm.com，下面一段话摘自Git</a> 官网：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a free and open source distributed version control system </span><br><span class="line">designed to handle everything from small to very large projects with </span><br><span class="line">speed and efficiency.</span><br></pre></td></tr></table></figure></p>
<h4 id="Git-的诞生"><a href="#Git-的诞生" class="headerlink" title="Git 的诞生"></a>Git 的诞生</h4><p>1991年，芬兰学生Linus Torvalds 开发出Linux 操作系统内核。为了获得更多人的一些修改建议，Linus 便将内核代码发布到网络上供大家下载。<br>Linux 内核开源项目有着来为数众多的参与者，这么多人都在为Linux 编写代码，<br>那么这些代码是如何管理的呢？早期的时候（1991-2002年），开发者把源代码通过diff的方式发送给Linus，然后由Linus本人通过手工方式合并代码！<br>这导致绝大多数Linux 内核维护的时间都花费在提交补丁和保存归档等非关键性工作上。</p>
<p>虽然当时已经存在很多商用的版本控制系统（Version Control System），但是与Linux的开源精神不符。<br>同时也是拒绝使用CVS 和 SVN等集中式版本控制系统，因为这些系统对网络要求较高，并且速度较慢。<br>到了2002年，BitMover公司免费提供分布式版本控制系统BitKeeper<br>给Linux社区来管理和维护Linux代码。2005年，由于产生一些矛盾，两者之间的的合作终止，他们回收了Linux 内核社区免费使用BitKeeper 的权限。<br>同年，Linus Torvalds 花了两周时间自己用C开发了一个分布式版本控制系统，这就是Git。（这就是大牛造轮子的速度！）<br>Git 的目标：</p>
<ul>
<li>速度</li>
<li>简单</li>
<li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li>
<li>完全分布式</li>
<li>有能力高效管理类似Linux 内核一样超大规模项目（速度和数据量）</li>
</ul>
<p>自诞生于2005年以来，Git 迅速成为最流行的分布式版本控制系统。<br>尤其是2008年，<a href="https://github.com" target="_blank" rel="noopener">GitHub</a> 网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移到GitHub。<br>很多组织和个人都在GitHub 上开源自己的代码，贡献很多优秀的项目。下图是Linus Torvalds 在GitHub上的主页。<br><img src="/2019/05/21/git/linus.png" title="Linus Torvalds"></p>
<p>GitHub 可以托管各种Git库，并提供一个Web界面，允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。<br>GitHub 时间轴：</p>
<ul>
<li>2007年10月1日开始开发；</li>
<li>2008年2月以beta版本开始上线，4月份正式上线；</li>
<li>2018年6月4日晚上，微软宣布以75亿美元的股票收购GitHub。</li>
</ul>
<h4 id="Git-几乎所有操作都在本地执行"><a href="#Git-几乎所有操作都在本地执行" class="headerlink" title="Git 几乎所有操作都在本地执行"></a>Git 几乎所有操作都在本地执行</h4><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。<br>如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面的速度绝对让你惊讶。<br>因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p>
<p>举个例子，要浏览项目的历史，Git 不需外连到服务器去获取，然后再显示出来，它只需直接从本地数据库中读取，你能立即看到项目历史。<br>如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，<br>而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。这也意味着你离线或者没有 VPN 时，几乎可以进行任何操作。 </p>
<p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的仅仅是用来方便交换大家的修改，<br>没有它大家也是一样干活，只是不太方便交换修改而已。</p>
<h4 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h4><p>Git 中的文件状态：<br>未跟踪(untracked)：新增的文件，并没有添加到 Git仓库，不参与版本控制；<br>已修改(modified)：表示已经修改了文件，还没有保存到本地数据库中；<br>已暂存(staged)：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中；<br>已提交(committed)：表示数据已经安全的保存在本地数据库中。</p>
<p>三个工作区域</p>
<ul>
<li>工作目录：在自己电脑在磁盘上供你使用或修改的文件目录；</li>
<li>暂存区(Index/Stage)：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域；</li>
<li>Git 仓库：Git 用来保存项目的元数据和对象数据库的地方，就是工作区中的隐藏目录.git。<img src="/2019/05/21/git/areas.png" title="areas">
</li>
</ul>
<p>基本的 Git 工作流程如下：</p>
<ul>
<li>在工作目录中修改文件；</li>
<li>暂存文件，将文件的快照放入暂存区域；</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本文主要介绍了Git诞生的起因，Git 特点和 Git 工作流程，下一篇文章会介绍Git的安装和Git基本命令的使用。</p>
<p><a href="https://examples.javacodegeeks.com/software-development/git/git-diff-example/" target="_blank" rel="noopener">Git Diff Example</a><br>[Git Article]<a href="https://dzone.com/users/3208287/kristip.html" target="_blank" rel="noopener">https://dzone.com/users/3208287/kristip.html</a><br><a href="https://backlog.com/blog/git-vs-svn-version-control-system/" target="_blank" rel="noopener">Git vs. SVN</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/insight/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/insight/" itemprop="url">insight</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T13:55:58+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接下来会写技术内容包括<br>git<br>dubbo<br>redis<br>kafka<br>netty<br>java8<br>jvm</p>
<p>边看边记录，写代码，视频无法检索，视频最多看三遍。<br>Java8<br>Netty<br>JVM<br>Node<br>Spring</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/java-bytecode/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/java-bytecode/" itemprop="url">introduction-to-java-bytecode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-17T14:14:14+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://dzone.com/articles/introduction-to-java-bytecode" target="_blank" rel="noopener">阅读原文</a><br>Reading compiled Java bytecode can be tedious, even for experienced Java developers.<br>即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。</p>
<p>Why do we need to know about such low-level stuff in the first place?<br>首先，我们为什么需要知道这些底层的东西呢？</p>
<p>Here is a simple scenario that happened to me last week:<br>下面是上周发生在我身上的一个简单场景：</p>
<p>I had made some code changes on my machine a long time ago, compiled a JAR,<br>很久以前，我在自己的机器上修改了一些代码，编译成一个JAR包，</p>
<p>and deployed it on a server to test a potential fix for a performance issue.<br>并且部署在一台服务器上以测试性能问题的潜在修复。</p>
<p>Unfortunately, the code was never checked into a version control system,<br>不幸的是，这些代码从没有被检入版本控制系统，</p>
<p>and for whatever reason, the local changes were deleted without a trace.<br>并且由于一些原因，本地的修改被删除的毫无踪迹。</p>
<p>After a couple of months, I needed those changes in source form again (which took quite an effort to come up with),<br>几个月后，我再一次需要这些修改的源码（这需要付出很大的努力），<br>but I could not find them!<br>但是我没有找到它们！</p>
<p>Luckily the compiled code still existed on that remote server.<br>幸运的是编译后的代码依然存在远程服务器上。</p>
<p>So with a sigh of relief, I fetched the JAR again and opened it using a decompiler editor…<br>于是松了一口气，我再一次获取到JAR包并且使用反编译编辑器打开它…</p>
<p>Only one problem: The decompiler GUI is not a flawless tool, and out of the many classes in that JAR,<br>唯一的问题：反编译器GUI不是一个完美的工具，而且在这个JAR中有很多类，</p>
<p>for some reason, only the specific class I was looking to decompile caused a bug in the UI whenever I opened it, and the decompiler to crash!<br>由于某种原因，无论什么时候，我用反编译工具打开要查看的特定类就会引起一个UI bug，反编译器会崩溃！</p>
<p>Desperate times call for desperate measures. Fortunately, I was familiar with raw bytecode,<br>绝望的时候需要孤注一掷的对策。幸运的是，我熟悉原生字节码，</p>
<p>and I’d rather take some time manually decompiling some pieces of the code rather than work through the changes and testing them again.<br>并且，我宁愿花费一些时间手工反编译代码也不愿对更改进行重新测试。</p>
<p>Since I still remembered at least where to look in the code,<br>因为我至少还记得在哪里查看代码，</p>
<p>reading bytecode helped me pinpoint the exact changes and construct them back in source form.<br> (I made sure to learn from my mistake and preserve them this time!)<br>阅读字节码帮助我精确的定位实际改变的地方，并且使用源码的形式构造它们（我一定要从我的错误中吸取教训，这次一定要记住！）。</p>
<p>The nice thing about bytecode is that you learn its syntax once, then it applies on all Java supported platforms —<br>字节码的好处是你一旦学习它的语法，它可以应用于所有Java支持的平台 - </p>
<p>because it is an intermediate representation of the code, and not the actual executable code for the underlying CPU.<br>因为它表示一个中间代码，不是实际在CPU上执行的代码。</p>
<p>Moreover, bytecode is simpler than native machine code because the JVM architecture is rather simple,<br>另外，字节码比本地机器码简单因为Java虚拟机架构相当简单。</p>
<p>hence simplifying the instruction set. Yet another nice thing is that all instructions in this set are fully documented by Oracle.<br>因此简化了指令集，然而，另一件好事是指令集中所有指令完全由Oracle提供。</p>
<p>Before learning about the bytecode instruction set though, let’s get familiar with a few things about the JVM that are needed as a prerequisite.<br>学习字节码指令集之前， 让我们先熟悉一下JVM的基础，作为学习指令集的前提条件。</p>
<p>JVM Data Types</p>
<h4 id="JVM数据类型"><a href="#JVM数据类型" class="headerlink" title="JVM数据类型"></a>JVM数据类型</h4><p>Java is statically typed, which affects the design of the bytecode instructions such that an instruction expects itself to operate on values of specific types.<br>Java是静态类型的，这影响了指令字节码的设计，使得一个指令期望自己去操作指定类型的值。</p>
<p>For example, there are several add instructions to add two numbers: iadd, ladd, fadd, dadd.<br>例如，有几个两个数的相加指令：iadd, ladd, fadd, dadd。<br>They expect operands of type, respectively, int, long, float, and double.<br>它们期望操作的类型分别是int, long, float, 和 double。</p>
<p>The majority of bytecode has this characteristic of having different forms of the same functionality depending on the operand types.<br>根据操作类型不同，相同的功能有不同的形式，大多数字节码具有的特征。</p>
<p>The data types defined by the JVM are:<br>JVM定义的数据类型：</p>
<ul>
<li><p>Primitive types:<br>原生类型：</p>
<ul>
<li><p>Numeric types: byte (8-bit 2’s complement), short (16-bit 2’s complement), int (32-bit 2’s complement), long (64-bit 2’s complement), char (16-bit unsigned Unicode), float (32-bit IEEE 754 single precision FP), double (64-bit IEEE 754 double precision FP)<br>数字类型：byte(8bit), short(16bit), int(32bit), long(64bit), char(16bit), float(32bit), double(64bit)</p>
</li>
<li><p>boolean type<br>布尔类型</p>
</li>
<li><p>returnAddress: pointer to instruction<br>返回地址：指向指令</p>
</li>
</ul>
</li>
<li><p>Reference types:<br>引用类型</p>
<ul>
<li><p>Class types<br>类类型</p>
</li>
<li><p>Array types<br>数组类型</p>
</li>
<li><p>Interface types<br>接口类型</p>
</li>
</ul>
</li>
</ul>
<p>The boolean type has limited support in bytecode.<br>字节码对布尔类型的支持有限制。<br>For example, there are no instructions that directly operate on boolean values.<br>例如，没有指令直接操作布尔类型。</p>
<p>Boolean values are instead converted to int by the compiler and the corresponding int instruction is used.<br>编译器将boolean值转换为int，并使用相应的int指令。</p>
<p>Java developers should be familiar with all of the above types, except returnAddress, which has no equivalent programming language type.<br>Java开发人员应该熟悉上述所有类型，除了returnAddress类型，它没有等价的编程语言类型。</p>
<p>Stack-Based Architecture</p>
<h4 id="基于栈的架构"><a href="#基于栈的架构" class="headerlink" title="基于栈的架构"></a>基于栈的架构</h4><p>The simplicity of the bytecode instruction set is largely due to Sun having designed a stack-based VM architecture, as opposed to a register-based one.<br>字节码指令集的简单性很大程度上归功于Sun设计了基于栈的VM 架构，而不是基于寄存器的架构。</p>
<p>There are various memory components used by a JVM process, but only the JVM stacks need to be examined in detail to essentially be able to follow bytecode instructions:<br>JVM 进程使用了各种内存组件，但是只需要详细检查JVM 栈，以便能够遵循字节码指令：</p>
<p>PC register: for each thread running in a Java program, a PC register stores the address of the current instruction.<br>程序计数器：对于每个运行在Java进程中的线程，PC 寄存器存储当前指令的地址。</p>
<p>JVM stack: for each thread, a stack is allocated where local variables, method arguments,<br>and return values are stored. Here is an illustration showing stacks for 3 threads.<br>JVM 栈：对于每个线程，被申请的栈用于存储本地变量，方法参数，返回值。下面是显示3个线程的堆栈图。</p>
<img src="/2019/05/17/java-bytecode/jvm_stacks.png" title="jvm stack">
<p>Heap: memory shared by all threads and storing objects (class instances and arrays).<br>堆：堆内存被所有线程共享，用来存储对象（类实例和数组）。<br>Object deallocation is managed by a garbage collector.<br>对象的释放由垃圾收集器管理。</p>
<img src="/2019/05/17/java-bytecode/heap.png" title="heap">
<p>Method area: for each loaded class, it stores the code of methods and a table of symbols<br>(e.g. references to fields or methods) and constants known as the constant pool.<br>方法区：对于每个加载的类，它存储了方法代码和符号表（例如，对字段或方法的引用）。和称为常量池的常量。<br><img src="/2019/05/17/java-bytecode/method_area.png" title="method area"></p>
<p>A JVM stack is composed of frames, each pushed onto the stack when a method is invoked and<br>popped from the stack when the method completes (either by returning normally or by throwing an exception).<br>JVM 栈由栈帧组成，每个栈帧在方法调用时被压入栈，方法完成时从栈顶弹出（通过正常返回或抛出异常）。</p>
<p>Each frame further consists of:<br>每个栈帧还包括：</p>
<ul>
<li><p>An array of local variables, indexed from 0 to its length minus 1.<br>The length is computed by the compiler.<br>A local variable can hold a value of any type, except long and double values, which occupy two local variables.<br>局部变量的数组，索引从0 到长度减1，长度是由编译器计算。<br>局部变量可以保存任意类型的值，long 和 double 类型的值除外，它们占用两个局部变量。</p>
</li>
<li><p>An operand stack used to store intermediate values that would act as operands for instructions,<br>or to push arguments to method invocations.<br>一个操作数栈用于存储中间值，该中间值将充当指令的操作数，或者压入参数到方法调用。</p>
<img src="/2019/05/17/java-bytecode/stack_frame_zoom.png" title="stack frame">
</li>
</ul>
<h4 id="Bytecode-Explored"><a href="#Bytecode-Explored" class="headerlink" title="Bytecode Explored"></a>Bytecode Explored</h4><h4 id="探索字节码"><a href="#探索字节码" class="headerlink" title="探索字节码"></a>探索字节码</h4><p>With an idea about the internals of a JVM, we can look at some basic bytecode example generated from sample code.<br>Each method in a Java class file has a code segment that consists of a sequence of instructions,<br>each having the following format:<br>了解 JVM 的内部结构，我们可以看一下从示例代码生成的一些基本字节码示例。<br>Java class文件中的每个方法都有一个由一系列指令组成的代码片段，每个都有以下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcode (1 byte)      operand1 (optional)      operand2 (optional)      ...</span><br></pre></td></tr></table></figure></p>
<p>That is an instruction that consists of one-byte opcode and zero or more operands that contain the data to operate.<br>这是由一个字节的操作码和零个或多个操作数组成的一个指令，</p>
<p>Within the stack frame of the currently executing method, an instruction can push or pop values onto the operand stack,<br>and it can potentially load or store values in the array local variables. Let’s look at a simple example:<br>在当前正在执行的方法的栈帧内部，一个指令可以压入或弹出值到一个操作数栈，并且它可以在数组局部变量中加载或存储值。<br>让我们看一个简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In order to print the resulting bytecode in the compiled class (assuming it is in a file Test.class),<br>we can run the <code>javap</code> tool:<br>为了在编译的类中打印生成的字节码（假设它在一个Test.class文件中），我们可以运行javap 工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Test.class</span><br></pre></td></tr></table></figure></p>
<p>And we get:<br>然后我们得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=4, args_size=1</span><br><span class="line">0: iconst_1</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_2</span><br><span class="line">3: istore_2</span><br><span class="line">4: iload_1</span><br><span class="line">5: iload_2</span><br><span class="line">6: iadd</span><br><span class="line">7: istore_3</span><br><span class="line">8: return</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>We can see the method signature for the main method,<br>a descriptor that indicates that the method takes an array of Strings ([Ljava/lang/String; ),<br> and has a void return type (V ).<br> A set of flags follow that describe the method as public (ACC_PUBLIC) and static (ACC_STATIC).<br>我们可以看到主方法的方法签名，一个描述符表示该方法使用字符串数组([Ljava/lang/String; )，并且具有空返回值类型（V）。<br>下面的一组flags描述了方法是公开的(ACC_PUBLIC) 并且是静态的 (ACC_STATIC)。</p>
<p>The most important part is the Code attribute,<br>最重要的部分是代码属性，<br>which contains the instructions for the method along with information<br>such as the maximum depth of the operand stack (2 in this case),<br>and the number of local variables allocated in the frame for this method (4 in this case).<br>其中包含方法说明和信息，例如操作数栈的最大深度（在本例中为2），以及此方法在栈帧中分配的局部变量数（在本例中为4）。</p>
<p>All local variables are referenced in the above instructions except the first one (at index 0),<br>which holds the reference to the args argument.<br>The other 3 local variables correspond to variables a, b and c in the source code.<br>除了第一个（索引0）之外，上述指令中引用了所有的局部变量，它保存了对args参数的引用。<br>其他3个局部变量对应源码中的变量 a, b 和c。</p>
<p>The instructions from address 0 to 8 will do the following:<br>从地址0到8的指令将执行以下操作：</p>
<p>iconst_1: Push the integer constant 1 onto the operand stack.<br>iconst_1：将整型常量1压入到操作数栈。<br><img src="/2019/05/17/java-bytecode/iconst_12.png" title="iconst_1"></p>
<p>istore_1: Pop the top operand (an int value) and store it in local variable at index 1, which corresponds to variable a.<br>istore_1：弹出顶部操作数（一个整型值）并将其存储在索引1的局部变量中，该变量对应于变量a。<br><img src="/2019/05/17/java-bytecode/istore_11.png" title="istore_1"></p>
<p>iconst_2: Push the integer constant 2 onto the operand stack.<br>iconst_2: 将整型常量2压入到操作数栈。<br><img src="/2019/05/17/java-bytecode/iconst_2.png" title="iconst_2"></p>
<p>istore_2: Pop the top operand int value and store it in local variable at index 2, which corresponds to variable b.<br>istore_2：弹出顶部操作数整型值，并将其存储在索引2的局部变量中，该变量对应于变量b。<br><img src="/2019/05/17/java-bytecode/istore_2.png" title="istore_2"></p>
<p>iload_1: Load the int value from local variable at index 1 and push it onto the operand stack.<br>iload_1: 从索引1的局部变量加载整型值，并且将它压入操作数栈。<br><img src="/2019/05/17/java-bytecode/iload_1.png" title="iload_1"></p>
<p>iload_2: Load the int value from the local variable at index 2 and push it onto the operand stack.<br>iload_2: 从索引2的局部变量加载整型值，并且将它压入操作数栈。<br><img src="/2019/05/17/java-bytecode/iload_2.png" title="iload_2"></p>
<p>iadd: Pop the top two int values from the operand stack, add them, and push the result back onto the operand stack.<br>iadd: 从操作数栈顶部弹出两个整型值，将它们相加，并且将结果压回到操作数栈。<br><img src="/2019/05/17/java-bytecode/iadd.png" title="iadd"></p>
<p>istore_3: Pop the top operand int value and store it in local variable at index 3, which corresponds to variable c.<br>istore_3: 弹出操作数顶部的整型值，并将其存储在索引3的局部变量中，该变量对应于变量c。<br><img src="/2019/05/17/java-bytecode/istore_3.png" title="istore_3"></p>
<p>return: Return from the void method.<br>return: 从void 方法返回。</p>
<p>Each of the above instructions consists of only an opcode, which dictates exactly the operation to be executed by the JVM.<br>上面的每个指令仅由一个操作码组成，它精确地指示JVM要执行的操作。</p>
<h4 id="Method-Invocations"><a href="#Method-Invocations" class="headerlink" title="Method Invocations"></a>Method Invocations</h4><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>In the above example, there is only one method, the main method.<br>Let’s assume that we need to a more elaborate computation for the value of variable c,<br>and we decide to place that in a new method called calc:<br>在上面示例中只有一个方法，主方法。<br>让我们假设我们需要对变量c的值进行一个更复杂的计算，我们决定将其放在一个名为calc的新方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = calc(a, b);</span><br><span class="line">&#125;</span><br><span class="line">static int calc(int a, int b) &#123;</span><br><span class="line">    return (int) Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Let’s see the resulting bytecode:<br>让我们看看生成的字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=4, args_size=1</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_2</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_1</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: invokestatic  #2         // Method calc:(II)I</span><br><span class="line">       9: istore_3</span><br><span class="line">      10: return</span><br><span class="line">static int calc(int, int);</span><br><span class="line">  descriptor: (II)I</span><br><span class="line">  flags: (0x0008) ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=6, locals=2, args_size=2</span><br><span class="line">       0: iload_0</span><br><span class="line">       1: i2d</span><br><span class="line">       2: ldc2_w        #3         // double 2.0d</span><br><span class="line">       5: invokestatic  #5         // Method java/lang/Math.pow:(DD)D</span><br><span class="line">       8: iload_1</span><br><span class="line">       9: i2d</span><br><span class="line">      10: ldc2_w        #3         // double 2.0d</span><br><span class="line">      13: invokestatic  #5         // Method java/lang/Math.pow:(DD)D</span><br><span class="line">      16: dadd</span><br><span class="line">      17: invokestatic  #6         // Method java/lang/Math.sqrt:(D)D</span><br><span class="line">      20: d2i</span><br><span class="line">      21: ireturn</span><br></pre></td></tr></table></figure>
<p>The only difference in the main method code is that instead of having the iadd instruction,<br>we now an invokestatic instruction, which simply invokes the static method calc.<br>The key thing to note is that the operand stack contained the two arguments that are passed to the method calc.<br>In other words, the calling method prepares all arguments of the to-be-called method by pushing them<br>onto the operand stack in the correct order.<br>invokestatic (or a similar invoke instruction, as will be seen later) will subsequently pop these arguments,<br>and a new frame is created for the invoked method where the arguments are placed in its local variable array.<br>在主方法代码中唯一不同的是，不是使用iadd 命令，我们现在是一个 invokestatic 命令，它只是调用静态方法calc。<br>关键需要注意的是，操作数栈包含传递给方法calc的两个参数。<br>换句话说，调用方法准备被调用方法的所有参数，通过以正确的顺序压入它们到操作数栈。<br>invokestatic（或者类似的调用命令，稍后将会看到）将随后弹出这些参数，<br>并为调用的方法创建一个新的栈帧，其中参数放在其局部变量数组中。</p>
<p>We also notice that the invokestatic instruction occupies 3 bytes by looking at the address, which jumped from 6 to 9.<br>This is because, unlike all instructions seen so far,<br>invokestatic includes two additional bytes to construct the reference to the method to be invoked (in addition to the opcode).<br>The reference is shown by javap as #2, which is a symbolic reference to the calc method,<br>which is resolved from the constant pool described earlier.<br>我们也注意到通过查看地址 invokestatic 命令占用3个字节，地址从6跳到9。<br>这是因为不像目前看到的所有指令，invokestatic 指令包含两个附加的字节来构造调用方法的引用（除了操作码）。<br>该引用由javap 显示为2，它是calc方法的符号引用，这是从前面描述的常量池中解析出来的。</p>
<p>The other new information is obviously the code for the calc method itself.<br>It first loads the first integer argument onto the operand stack (iload_0).<br>The next instruction, i2d, converts it to a double by applying widening conversion.<br>The resulting double replaces the top of the operand stack.<br>其他新信息显然是calc方法本身的代码。<br>它首先加载第一个整型参数到操作数栈（iload_0）。<br>下一个指令i2d，通过应用扩展转换将其转换为double。<br>结果double 替换操作数栈顶。</p>
<p>The next instruction pushes a double constant 2.0d  (taken from the constant pool) onto the operand stack.<br>Then the static Math.pow method is invoked with the two operand values prepared so far<br>(the first argument to calc and the constant 2.0d).<br>When the Math.pow method returns, its result will be stored on the operand stack of its invoker.<br>This can be illustrated below.<br>下一个指令压入一个double类型的常量2.0d（取自常量池）到操作数栈。<br>然后使用到目前为止准备的两个操作数值调用静态方法Math.pow（calc方法的第一个参数和常量2.0d)。<br>当Math.pow 方法返回时，其结果存储在其调用者的操作数栈。这可以在下面说明。<br><img src="/2019/05/17/java-bytecode/math_pow2.png" title="math pow"></p>
<p>The same procedure is applied to compute Math.pow(b, 2):<br>计算Math.pow(b, 2)是相似的过程：<br><img src="/2019/05/17/java-bytecode/math_pow21.png" title="math pow"></p>
<p>The next instruction, dadd, pops the top two intermediate results, adds them, and pushes the sum back to the top.<br>Finally, invokestatic invokes Math.sqrt on the resulting sum,<br>and the result is cast from double to int using narrowing conversion (d2i).<br>The resulting int is returned to the main method, which stores it back to c (istore_3).<br>下一个指令dadd 弹出栈顶的两个中间结果，相加，将相加结果压回栈顶。<br>最后，invokestatic 调用Math.sqrt<br>并且使用强制转换（d2i）将结果从double 转换成int。<br>int类型的结果被返回到main方法，存储到变量c（istore_3）。</p>
<h4 id="Instance-Creations"><a href="#Instance-Creations" class="headerlink" title="Instance Creations"></a>Instance Creations</h4><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>Let’s modify the example and introduce a class Point to encapsulate XY coordinates.<br>让我们修改示例并引入Point类来封装XY坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point a = new Point(1, 1);</span><br><span class="line">        Point b = new Point(5, 3);</span><br><span class="line">        int c = a.area(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Point &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    public int area(Point b) &#123;</span><br><span class="line">        int length = Math.abs(b.y - this.y);</span><br><span class="line">        int width = Math.abs(b.x - this.x);</span><br><span class="line">        return length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The compiled bytecode for the main method is shown below:<br>main方法的编译字节码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=4, locals=4, args_size=1</span><br><span class="line">       0: new           #2       // class test/Point</span><br><span class="line">       3: dup</span><br><span class="line">       4: iconst_1</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: invokespecial #3       // Method test/Point.&quot;&lt;init&gt;&quot;:(II)V</span><br><span class="line">       9: astore_1</span><br><span class="line">      10: new           #2       // class test/Point</span><br><span class="line">      13: dup</span><br><span class="line">      14: iconst_5</span><br><span class="line">      15: iconst_3</span><br><span class="line">      16: invokespecial #3       // Method test/Point.&quot;&lt;init&gt;&quot;:(II)V</span><br><span class="line">      19: astore_2</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: invokevirtual #4       // Method test/Point.area:(Ltest/Point;)I</span><br><span class="line">      25: istore_3</span><br><span class="line">      26: return</span><br></pre></td></tr></table></figure></p>
<p>The new instructions encountereted here are new , dup, and invokespecial.<br>这里遇到的新指令是new, dup 和 invokespecial。</p>
<p>Similar to the new operator in the programming language,<br>the new instruction creates an object of the type specified in the operand passed to it<br> (which is a symbolic reference to the class Point).<br>Memory for the object is allocated on the heap, and a reference to the object is pushed on the operand stack.<br>与编程语言中的new 运算符类似，new 指令创建一个传递给它的操作数中指定类型的对象（这是Point类的符号引用）。<br>对象的内存在堆上分配，对象的引用是被压入操作数栈。</p>
<p>The dup instruction duplicates the top operand stack value,<br>which means that now we have two references the Point object on the top of the stack.<br>dup 指令复制操作数栈顶值，这意味着现在我们在栈顶有两个引用Point对象。</p>
<p>The next three instructions push the arguments of the constructor<br>(used to initialize the object) onto the operand stack,<br>and then invoke a special initialization method, which corresponds with the constructor.<br>接下来三个指令将构造方法（用于初始化对象）的参数压入到操作数栈上，然后调用一个特殊的初始化方法，该方法与构造方法对应。</p>
<p>The next method is where the fields x and y will get initialized.<br>After the method is finished, the top three operand stack values are consumed,<br>and what remains is the original reference to the created object (which is, by now, successfully initialized).<br>下一个方法是属性x 和 y 将得到初始化，方法完成后，顶部三个操作数值被消费，<br>剩下来的是对创建对象的原始引用（这时初始化成功）。<br><img src="/2019/05/17/java-bytecode/init.png" title="init"></p>
<p>Next, astore_1 pops that Point reference and assigns it to the local variable at index 1<br>(the a in astore_1 indicates this is a reference value).<br>接下来，astore_1 弹出Point引用并将其分配给索引为1的局部变量（astore_1中的a表示这是引用值）。<br><img src="/2019/05/17/java-bytecode/init_store.png" title="init_store"></p>
<p>The same procedure is repeated for creating and initializing the second Point instance,<br> which is assigned to variable b.<br>重复相似的过程来创建和初始化第二个Point实例，分配给变量b。<br><img src="/2019/05/17/java-bytecode/init2.png" title="init"><br><img src="/2019/05/17/java-bytecode/init_store2.png" title="init_store"></p>
<p>The last step loads the references to the two Point objects from local variables at indexes 1 and 2<br>(using aload_1 and aload_2 respectively), and invokes the area method using invokevirtual,<br>which handles dispatching the call to the appropriate method based on the actual type of the object.<br>最后一步从局部变量的索引1和2中加载对两个Point对象的引用（分别使用aload_1 和 aload_2指令），<br>并且使用invokevirtual 指令调用area方法，它处理根据对象的实际类型将调用到适当的方法。</p>
<p>For example, if the variable a contained an instance of type SpecialPoint that extends Point,<br>and the subtype overrides the area method, then the overriden method is invoked.<br>In this case, there is no subclass, and hence only one area method is available.<br>例如，如果变量a 包含一个继承了Point的SpecialPoint类型的实例，并且子类型重写了area方法，然后重写的方法被调用。<br>在这个例子中，没有子类，因此只有一个area方法是可用的。<br><img src="/2019/05/17/java-bytecode/area2.png"></p>
<p>Note that even though the area method accepts one argument,<br>there are two Point references on the top of the stack.<br>注意，即使area方法接收一个参数，在栈顶有两个Point引用。</p>
<p>The first one (pointA, which comes from variable a) is actually the instance<br>on which the method is invoked (otherwise referred to as this in the programming language),<br>and it will be passed in the first local variable of the new frame for the area method.<br>The other operand value (pointB) is the argument to the area method.<br>第一个（PointA 来自变量a）是调用方法的实际实例（在编程语言中称为this），<br>它将在area方法的新帧的第一个局部变量中传递。另一个操作数值（pointB）是area方法的参数。</p>
<h4 id="The-Other-Way-Around"><a href="#The-Other-Way-Around" class="headerlink" title="The Other Way Around"></a>The Other Way Around</h4><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>You don’t need to master the understanding of each instruction<br>and the exact flow of execution to gain an idea about what the program does based on the bytecode at hand.<br>For example, in my case, I wanted to check if the code employed a Java stream to read a file,<br>and whether the stream was properly closed.<br>Now given the following bytecode, it is relatively easy to determine that indeed a stream is used<br>and most likely it is being closed as part of a try-with-resources statement.<br>你不需要掌握每个指令的意义，以及确切的执行流程，以便于根据字节码了解程序的功能。<br>例如，在我的情况下，我想检查代码是否使用Java流读取文件， 以及流是否正确关闭。<br>现在给出如下的字节码，它是相对容易的确定确实使用了流，并且很可能它是作为try-with-resources的一部分而被关闭的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]) throws java.lang.Exception;</span><br><span class="line"> descriptor: ([Ljava/lang/String;)V</span><br><span class="line"> flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line"> Code:</span><br><span class="line">   stack=2, locals=8, args_size=1</span><br><span class="line">      0: ldc           #2                  // class test/Test</span><br><span class="line">      2: ldc           #3                  // String input.txt</span><br><span class="line">      4: invokevirtual #4                  // Method java/lang/Class.getResource:(Ljava/lang/String;)Ljava/net/URL;</span><br><span class="line">      7: invokevirtual #5                  // Method java/net/URL.toURI:()Ljava/net/URI;</span><br><span class="line">     10: invokestatic  #6                  // Method java/nio/file/Paths.get:(Ljava/net/URI;)Ljava/nio/file/Path;</span><br><span class="line">     13: astore_1</span><br><span class="line">     14: new           #7                  // class java/lang/StringBuilder</span><br><span class="line">     17: dup</span><br><span class="line">     18: invokespecial #8                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     21: astore_2</span><br><span class="line">     22: aload_1</span><br><span class="line">     23: invokestatic  #9                  // Method java/nio/file/Files.lines:(Ljava/nio/file/Path;)Ljava/util/stream/Stream;</span><br><span class="line">     26: astore_3</span><br><span class="line">     27: aconst_null</span><br><span class="line">     28: astore        4</span><br><span class="line">     30: aload_3</span><br><span class="line">     31: aload_2</span><br><span class="line">     32: invokedynamic #10,  0             // InvokeDynamic #0:accept:(Ljava/lang/StringBuilder;)Ljava/util/function/Consumer;</span><br><span class="line">     37: invokeinterface #11,  2           // InterfaceMethod java/util/stream/Stream.forEach:(Ljava/util/function/Consumer;)V</span><br><span class="line">     42: aload_3</span><br><span class="line">     43: ifnull        131</span><br><span class="line">     46: aload         4</span><br><span class="line">     48: ifnull        72</span><br><span class="line">     51: aload_3</span><br><span class="line">     52: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">     57: goto          131</span><br><span class="line">     60: astore        5</span><br><span class="line">     62: aload         4</span><br><span class="line">     64: aload         5</span><br><span class="line">     66: invokevirtual #14                 // Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V</span><br><span class="line">     69: goto          131</span><br><span class="line">     72: aload_3</span><br><span class="line">     73: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">     78: goto          131</span><br><span class="line">     81: astore        5</span><br><span class="line">     83: aload         5</span><br><span class="line">     85: astore        4</span><br><span class="line">     87: aload         5</span><br><span class="line">     89: athrow</span><br><span class="line">     90: astore        6</span><br><span class="line">     92: aload_3</span><br><span class="line">     93: ifnull        128</span><br><span class="line">     96: aload         4</span><br><span class="line">     98: ifnull        122</span><br><span class="line">    101: aload_3</span><br><span class="line">    102: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">    107: goto          128</span><br><span class="line">    110: astore        7</span><br><span class="line">    112: aload         4</span><br><span class="line">    114: aload         7</span><br><span class="line">    116: invokevirtual #14                 // Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V</span><br><span class="line">    119: goto          128</span><br><span class="line">    122: aload_3</span><br><span class="line">    123: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">    128: aload         6</span><br><span class="line">    130: athrow</span><br><span class="line">    131: getstatic     #15                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    134: aload_2</span><br><span class="line">    135: invokevirtual #16                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    138: invokevirtual #17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    141: return</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>We see occurrences of java/util/stream/Stream where forEach is called,<br>preceded by a call to InvokeDynamic with a reference to a Consumer.<br>我们看到java/util/stream/Stream的出现在forEach被调用的地方，之前调用InvokeDynamic 并引用Consumer。</p>
<p>And then we see a chunk of bytecode that calls Stream.close along with branches that call Throwable.addSuppressed.<br>然后我们看到大块字节码调用Stream.close 以及调用Throwable.addSuppressed 的分支。</p>
<p>This is the basic code that gets generated by the compiler for a try-with-resources statement.<br>这是编译器为try-with-resources语句生成的基本代码。</p>
<p>Here’s the original source for completeness:<br>以下是完整的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Path path = Paths.get(Test.class.getResource(&quot;input.txt&quot;).toURI());</span><br><span class="line">    StringBuilder data = new StringBuilder();</span><br><span class="line">    try(Stream lines = Files.lines(path)) &#123;</span><br><span class="line">        lines.forEach(line -&gt; data.append(line).append(&quot;\n&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(data.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Thanks to the simplicity of the bytecode instruction set<br>and the near absence of compiler optimizations when generating its instructions,<br>disassembling class files could be one way to examine changes into<br>your application code without having the source, if that ever becomes a need.<br>由于字节码指令集的简化，并且在生成其指令时几乎没有编译器优化，<br>在你的应用程序代码没有源码，如果需要的话，反编译类文件可能是检查更改的一种方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/data-structure/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/26/data-structure/" itemprop="url">data-structure</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-26T08:50:04+08:00">
                2019-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><p>从广义上讲，数据结构就是一组数据的存储结构，算法就是操作数据的一组方法。<br>从狭义上讲，是指某些著名的数据结构和算法，比如队列、堆、栈、二分查找、动态规划等。</p>
<p>数据结构和算法本身解决的是快和省的问题，即让代码运行的更快，让代码更省存储空间。<br>所以，执行效率是算法一个非常重要的衡量指标。<br>时间和空间复杂度分析用来衡量算法的执行效率，可以粗略地估计算法的执行效率。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>时间复杂度的全称是渐进时间复杂度，表示算法执行时间与数据规模之间的增长关系。</p>
<ul>
<li>只关注循环执行次数最多的一段代码，通常会忽略公式中的常量、低阶、系数，只需要记录一个最大阶的量级；</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度；</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</li>
</ul>
<p>常见时间复杂度<br>常量阶O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。<br>对数阶O(logn)<br>线性阶O(n)、O(m+n)、O(m*n)<br>线性对数阶O(nlogn)<br>平方阶O(n^2)、立方阶O(n^3)、k方阶O(n^k)<br>指数阶O(2^n)<br>阶乘阶O(n!)</p>
<p>越高阶复杂度的算法，执行效率越低。<br>从低到高有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)</p>
<p>空间复杂度<br>空间复杂度的全称是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p>
<p>最好情况时间复杂度<br>最坏情况时间复杂度<br>平均情况时间复杂度<br>均摊时间复杂度</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是一种<code>线性表</code>数据结构，它用一组<code>连续的内存空间</code>，来存储一组具有<code>相同类型的数据</code>。<br>线性表：数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。链表、队列、栈也是线性表结构。<br>非线性表：比如二叉树、堆、图等，之所以叫非线性，是因为在非线性表中数据之间并不是简单的前后关系。<br>连续的内存空间和相同类型的数据：数组根据下标可以随机访问。</p>
<p>低效的插入和删除</p>
<ul>
<li><p>插入：假设数组的长度为n，如果在中间第k个位置插入元素，那么k之后的元素都要往后移动一位，<br>如果在数组末尾插入元素，就不用移动数据了，最好时间复杂度为O(1)，<br>如果在数组的开头插入元素，那所有的数据都需要往后移动一位，最坏时间复杂度为O(n)。<br>优化方案：如果数组中存储的元素并没有任何规律，数组只是存储数据的集合，这种情况下，如果要在第k个位置插入一条数据，为了避免数据移动，<br>可以直接将第k个位置数据移动到数组元素的最后，然后把新的元素放入第k个位置，这种情况下在第k个位置插入元素的时间复杂度降为O(1)。</p>
</li>
<li><p>删除<br>….</p>
</li>
</ul>
<p>容器能否完全替代数组？<br>针对数组类型，很多语言提供了容器类，比如Java中的ArrayList、C++ STL中的vector。<br>容器类最大的优势是将很多数组操作的细节封装起来，比如对于插入和删除操作引起的数据移动不用开发人员自己实现，还有一个是支持动态扩容。<br>在创建ArrayList时，如果事先能够确定要存储数据的大小，最好在创建容器时指定大小，可以减少内存申请与数据移动。</p>
<p>适合使用数组的场景：</p>
<ul>
<li>Java ArrayList 无法存储基本数据类型，比如int、long 需要封装为Integer、Long类，而自动装箱和自动拆箱有一定的性能损耗。<br>如果特别关注性能，或者希望使用基本类型，就可以选择数组；</li>
<li>如果数据大小事先已知，并且对数据操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组；</li>
<li>当表示多维数组时，用数组更加直观。</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种操作受限的数据结构，只支持入栈和出栈操作。先进后出是它最大的特点。</p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存空间被组织成“栈”这种数据结构，用来存储函数调用时的临时变量。<br>每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>先进先出<br>入队：放一个数据到队列的尾部。<br>出队：从队列头部取一个元素。<br>用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。<br>循环队列<br>阻塞队列<br>并发队列</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>三个条件：</p>
<ul>
<li>一个问题的解可以分解为几个子问题的解；</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；</li>
<li>存在递归终止条件。<br>如何编写递归代码<br>写出递推公式，找到终止条件，将递推公式转化成代码。</li>
</ul>
<p>递归代码问题</p>
<ul>
<li>堆栈溢出</li>
<li>重复计算</li>
<li>函数调用耗时多</li>
<li>空间复杂度高</li>
</ul>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>稳定性：待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的顺序保持不变，则叫作<code>稳定的排序算法</code>，否则叫作<code>不稳定的排序算法</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/python/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/python/" itemprop="url">python</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T13:41:08+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://wizardforcel.gitbooks.io/pyda-2e/content/1.html" target="_blank" rel="noopener">python数据分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/jvm/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/jvm/" itemprop="url">jvm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T15:20:22+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类加载器深入解析与阶段分解"><a href="#类加载器深入解析与阶段分解" class="headerlink" title="类加载器深入解析与阶段分解"></a>类加载器深入解析与阶段分解</h3><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><ul>
<li>在Java代码中，<code>类型</code>（class）的加载、连接与初始化过程都是在程序<code>运行期间</code>完成的；</li>
<li>通过这种方式提供了更大的灵活性，增加了更多的可能性。</li>
</ul>
<h4 id="阶段分解"><a href="#阶段分解" class="headerlink" title="阶段分解"></a>阶段分解</h4><ul>
<li>加载：查找并加载类的二进制数据，将类的class文件加载到内存；</li>
<li>连接：<br>  将类与类的关系给确定好，将类与类之间符号引用转换成直接引用，并且对字节码进行相关的处理、验证。<ul>
<li>验证：确保被加载类的正确性；</li>
<li>准备：为类的<code>静态变量</code>（类变量）分配内存，并将其<code>初始化为默认值</code>，但在到达初始化之前，类变量都没有初始化为真正都初始值；</li>
<li>解析：把类中的符号引用转换为直接引用；</li>
</ul>
</li>
<li>初始化：为类的静态变量赋予正确的初始值（真实值覆盖默认值）。</li>
<li>使用<ul>
<li>类实例化：为新的对象分配内存，为实例变量赋默认值，为实例变量赋正确的初始值（开发人员设置的初始值）。</li>
</ul>
</li>
<li>卸载</li>
</ul>
<h4 id="类加载器Classloader"><a href="#类加载器Classloader" class="headerlink" title="类加载器Classloader"></a>类加载器Classloader</h4><p>Java虚拟机与程序的生命周期，在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了System.exit()方法；</li>
<li>程序正常执行结束；</li>
<li>程序在执行过程中遇到了异常或错误而异常终止；</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止。</li>
</ul>
<h3 id="类的加载连接与初始化过程详解"><a href="#类的加载连接与初始化过程详解" class="headerlink" title="类的加载连接与初始化过程详解"></a>类的加载连接与初始化过程详解</h3><h4 id="Java程序对类对使用方式可分为两种"><a href="#Java程序对类对使用方式可分为两种" class="headerlink" title="Java程序对类对使用方式可分为两种"></a>Java程序对类对使用方式可分为两种</h4><ul>
<li><p>主动使用：</p>
<ul>
<li>创建类的实例；</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值（被final修饰、已在编译期把结果放入常量池的静态字段除外）；</li>
<li>调用类的静态方法；</li>
<li>反射（如：Class.forName(“com.geekymv.MyTest”)）；</li>
<li>初始化一个类的子类；</li>
<li>Java虚拟机启动时被标明为启动类的类（包含main方法的类）；</li>
<li>jdk1.7开始提供的动态语言支持，java.lang.invoke.methodHandle实例的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化则初始化。</li>
</ul>
</li>
<li><p>被动使用：除了以上7种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>
</li>
</ul>
<p>所有的Java虚拟机实现必须在每个类或接口被Java程序<code>首次主动使用</code>才初始化。</p>
<p>类的初始化步骤</p>
<ul>
<li>假如这个类还没有被加载和连接，那就先进行加载和连接；</li>
<li>假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类；</li>
<li>假如类中存在初始化语句（静态变量的声明语句，以及静态代码块都被看做类的初始化语句），那就依次执行这些初始化语句。</li>
</ul>
<p>类的初始化时机<br>当Java虚拟机初始化一个类时，要求它的所有父类都已经初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口；</li>
<li>在初始化一个接口时，并不会初始化它的父接口。<br>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。<br>只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</li>
</ul>
<h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<code>方法区</code>内，然后在内存中创建一个java.lang.Class对象<br>（Java虚拟机规范中并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。</p>
<p>加载.class文件的方式</p>
<ul>
<li>从本地系统中直接加载；</li>
<li>通过网络下载.class文件；</li>
<li>从zip、jar等归档文件中加载.class文件；</li>
<li>从专有数据库中提取.class文件；</li>
<li>将Java源文件动态编译为.class文件。</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>Java虚拟机自带的加载器<ul>
<li>根类加载器（Bootstrap），或者叫做启动类加载器，该加载器没有父加载器，加载jre/lib/rt.jar 或者-Xbootclasspath选项指定的jar包；</li>
<li>扩展类加载器（Extension），加载jre/lib/ext/*.jar 或者-Djava.ext.dirs指定目录下的jar包；</li>
<li>系统类加载器（System）或者叫做应用类加载器，加载classpath 或则-Djava.class.path目录下的类和jar包；</li>
</ul>
</li>
<li>用户自定义的类加载器<ul>
<li>java.lang.ClassLoader 的子类</li>
<li>用户可以定制类的加载方式</li>
</ul>
</li>
</ul>
<p>// TODO 画图</p>
<p>除了根类加载器之外，其他的类加载器有且只有一个父加载器。<br>类加载器并不需要等到某个类”首次主动使用”时再加载它。</p>
<p>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或者存在错误，<br>类加载器必须在程序主动使用时才报告错误（LinkageError错误）。<br>如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p>双亲委托机制（父亲委托机制）<br>在父亲委托机制中，各个类加载器按照父子关系形成了树形结构（逻辑意义上的树形结构），<br>除了根类加载器，其余的类加载器有且只有一个父加载器。</p>
<p>通俗的说，就是一个类加载器自己要加载类，但是自己不去加载而是让自己的父类加载器尝试去加载，直到根类加载器，<br>然后由根类加载器尝试去加载，如果根类加载加载不了，则让子类加载器去加载，直到加载成功或者加载失败。</p>
<p>自底向上检查类是否已经加载，自顶向下尝试加载类。</p>
<p>扩展类加载器ExtClassLoader 和应用类加载器AppClassLoader（或称系统类加载器SystemClassLoader） 都是由启动类加载器BootstrapClassLoader 加载。<br>BootstrapClassLoader 是Java虚拟机内建的类加载器。</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。<br>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。<br>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p>
<p>子加载器加载的类可以访问父加载器加载的类，父加载器加载的类不能访问子加载器加载的类。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>监控工具使用<br>jconsole<br>jvisualvm<br>jmap<br>jstack</p>
<p>锁<br>线程安全<br>偏向锁、自旋锁与轻量级锁</p>
<p>逃逸分析<br>内存模型</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li>标记清除</li>
<li>复制算法</li>
<li><p>标记整理</p>
</li>
<li><p>分代收集<br>新生代：复制算法<br>老年代：标记清除或标记整理</p>
</li>
</ul>
<h4 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>CMS<br>G1</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">geekymv</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">geekymv</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>






        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  





  

  

  

  
  

  

  

  

</body>
</html>
