<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="阅读原文Reading compiled Java bytecode can be tedious, even for experienced Java developers.即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。 Why do we need to know about such low-level stuff in the first place?首先">
<meta property="og:type" content="article">
<meta property="og:title" content="introduction-to-java-bytecode">
<meta property="og:url" content="http://yoursite.com/2019/05/17/java-bytecode/index.html">
<meta property="og:site_name" content="geekymv">
<meta property="og:description" content="阅读原文Reading compiled Java bytecode can be tedious, even for experienced Java developers.即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。 Why do we need to know about such low-level stuff in the first place?首先">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/jvm_stacks.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/heap.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/method_area.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/stack_frame_zoom.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iconst_12.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/istore_11.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iconst_2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/istore_2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iload_1.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iload_2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iadd.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/istore_3.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/math_pow2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/math_pow21.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/init.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/init_store.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/init2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/init_store2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/area2.png">
<meta property="og:updated_time" content="2019-08-01T07:55:12.095Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="introduction-to-java-bytecode">
<meta name="twitter:description" content="阅读原文Reading compiled Java bytecode can be tedious, even for experienced Java developers.即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。 Why do we need to know about such low-level stuff in the first place?首先">
<meta name="twitter:image" content="http://yoursite.com/2019/05/17/java-bytecode/jvm_stacks.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/17/java-bytecode/">





  <title>introduction-to-java-bytecode | geekymv</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">geekymv</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Do one thing, do it well.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/java-bytecode/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">introduction-to-java-bytecode</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-17T14:14:14+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://dzone.com/articles/introduction-to-java-bytecode" target="_blank" rel="noopener">阅读原文</a><br>Reading compiled Java bytecode can be tedious, even for experienced Java developers.<br>即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。</p>
<p>Why do we need to know about such low-level stuff in the first place?<br>首先，我们为什么需要知道这些底层的东西呢？</p>
<p>Here is a simple scenario that happened to me last week:<br>下面是上周发生在我身上的一个简单场景：</p>
<p>I had made some code changes on my machine a long time ago, compiled a JAR,<br>很久以前，我在自己的机器上修改了一些代码，编译成一个JAR包，<br><a id="more"></a><br>and deployed it on a server to test a potential fix for a performance issue.<br>并且部署在一台服务器上以测试性能问题的潜在修复。</p>
<p>Unfortunately, the code was never checked into a version control system,<br>不幸的是，这些代码从没有被检入版本控制系统，</p>
<p>and for whatever reason, the local changes were deleted without a trace.<br>并且由于一些原因，本地的修改被删除的毫无踪迹。</p>
<p>After a couple of months, I needed those changes in source form again (which took quite an effort to come up with),<br>几个月后，我再一次需要这些修改的源码（这需要付出很大的努力），<br>but I could not find them!<br>但是我没有找到它们！</p>
<p>Luckily the compiled code still existed on that remote server.<br>幸运的是编译后的代码依然存在远程服务器上。</p>
<p>So with a sigh of relief, I fetched the JAR again and opened it using a decompiler editor…<br>于是松了一口气，我再一次获取到JAR包并且使用反编译编辑器打开它…</p>
<p>Only one problem: The decompiler GUI is not a flawless tool, and out of the many classes in that JAR,<br>唯一的问题：反编译器GUI不是一个完美的工具，而且在这个JAR中有很多类，</p>
<p>for some reason, only the specific class I was looking to decompile caused a bug in the UI whenever I opened it, and the decompiler to crash!<br>由于某种原因，无论什么时候，我用反编译工具打开要查看的特定类就会引起一个UI bug，反编译器会崩溃！</p>
<p>Desperate times call for desperate measures. Fortunately, I was familiar with raw bytecode,<br>绝望的时候需要孤注一掷的对策。幸运的是，我熟悉原生字节码，</p>
<p>and I’d rather take some time manually decompiling some pieces of the code rather than work through the changes and testing them again.<br>并且，我宁愿花费一些时间手工反编译代码也不愿对更改进行重新测试。</p>
<p>Since I still remembered at least where to look in the code,<br>因为我至少还记得在哪里查看代码，</p>
<p>reading bytecode helped me pinpoint the exact changes and construct them back in source form.<br> (I made sure to learn from my mistake and preserve them this time!)<br>阅读字节码帮助我精确的定位实际改变的地方，并且使用源码的形式构造它们（我一定要从我的错误中吸取教训，这次一定要记住！）。</p>
<p>The nice thing about bytecode is that you learn its syntax once, then it applies on all Java supported platforms —<br>字节码的好处是你一旦学习它的语法，它可以应用于所有Java支持的平台 - </p>
<p>because it is an intermediate representation of the code, and not the actual executable code for the underlying CPU.<br>因为它表示一个中间代码，不是实际在CPU上执行的代码。</p>
<p>Moreover, bytecode is simpler than native machine code because the JVM architecture is rather simple,<br>另外，字节码比本地机器码简单因为Java虚拟机架构相当简单。</p>
<p>hence simplifying the instruction set. Yet another nice thing is that all instructions in this set are fully documented by Oracle.<br>因此简化了指令集，然而，另一件好事是指令集中所有指令完全由Oracle提供。</p>
<p>Before learning about the bytecode instruction set though, let’s get familiar with a few things about the JVM that are needed as a prerequisite.<br>学习字节码指令集之前， 让我们先熟悉一下JVM的基础，作为学习指令集的前提条件。</p>
<p>JVM Data Types</p>
<h4 id="JVM数据类型"><a href="#JVM数据类型" class="headerlink" title="JVM数据类型"></a>JVM数据类型</h4><p>Java is statically typed, which affects the design of the bytecode instructions such that an instruction expects itself to operate on values of specific types.<br>Java是静态类型的，这影响了指令字节码的设计，使得一个指令期望自己去操作指定类型的值。</p>
<p>For example, there are several add instructions to add two numbers: iadd, ladd, fadd, dadd.<br>例如，有几个两个数的相加指令：iadd, ladd, fadd, dadd。<br>They expect operands of type, respectively, int, long, float, and double.<br>它们期望操作的类型分别是int, long, float, 和 double。</p>
<p>The majority of bytecode has this characteristic of having different forms of the same functionality depending on the operand types.<br>根据操作类型不同，相同的功能有不同的形式，大多数字节码具有的特征。</p>
<p>The data types defined by the JVM are:<br>JVM定义的数据类型：</p>
<ul>
<li><p>Primitive types:<br>原生类型：</p>
<ul>
<li><p>Numeric types: byte (8-bit 2’s complement), short (16-bit 2’s complement), int (32-bit 2’s complement), long (64-bit 2’s complement), char (16-bit unsigned Unicode), float (32-bit IEEE 754 single precision FP), double (64-bit IEEE 754 double precision FP)<br>数字类型：byte(8bit), short(16bit), int(32bit), long(64bit), char(16bit), float(32bit), double(64bit)</p>
</li>
<li><p>boolean type<br>布尔类型</p>
</li>
<li><p>returnAddress: pointer to instruction<br>返回地址：指向指令</p>
</li>
</ul>
</li>
<li><p>Reference types:<br>引用类型</p>
<ul>
<li><p>Class types<br>类类型</p>
</li>
<li><p>Array types<br>数组类型</p>
</li>
<li><p>Interface types<br>接口类型</p>
</li>
</ul>
</li>
</ul>
<p>The boolean type has limited support in bytecode.<br>字节码对布尔类型的支持有限制。<br>For example, there are no instructions that directly operate on boolean values.<br>例如，没有指令直接操作布尔类型。</p>
<p>Boolean values are instead converted to int by the compiler and the corresponding int instruction is used.<br>编译器将boolean值转换为int，并使用相应的int指令。</p>
<p>Java developers should be familiar with all of the above types, except returnAddress, which has no equivalent programming language type.<br>Java开发人员应该熟悉上述所有类型，除了returnAddress类型，它没有等价的编程语言类型。</p>
<p>Stack-Based Architecture</p>
<h4 id="基于栈的架构"><a href="#基于栈的架构" class="headerlink" title="基于栈的架构"></a>基于栈的架构</h4><p>The simplicity of the bytecode instruction set is largely due to Sun having designed a stack-based VM architecture, as opposed to a register-based one.<br>字节码指令集的简单性很大程度上归功于Sun设计了基于栈的VM 架构，而不是基于寄存器的架构。</p>
<p>There are various memory components used by a JVM process, but only the JVM stacks need to be examined in detail to essentially be able to follow bytecode instructions:<br>JVM 进程使用了各种内存组件，但是只需要详细检查JVM 栈，以便能够遵循字节码指令：</p>
<p>PC register: for each thread running in a Java program, a PC register stores the address of the current instruction.<br>程序计数器：对于每个运行在Java进程中的线程，PC 寄存器存储当前指令的地址。</p>
<p>JVM stack: for each thread, a stack is allocated where local variables, method arguments,<br>and return values are stored. Here is an illustration showing stacks for 3 threads.<br>JVM 栈：对于每个线程，被申请的栈用于存储本地变量，方法参数，返回值。下面是显示3个线程的堆栈图。</p>
<img src="/2019/05/17/java-bytecode/jvm_stacks.png" title="jvm stack">
<p>Heap: memory shared by all threads and storing objects (class instances and arrays).<br>堆：堆内存被所有线程共享，用来存储对象（类实例和数组）。<br>Object deallocation is managed by a garbage collector.<br>对象的释放由垃圾收集器管理。</p>
<img src="/2019/05/17/java-bytecode/heap.png" title="heap">
<p>Method area: for each loaded class, it stores the code of methods and a table of symbols<br>(e.g. references to fields or methods) and constants known as the constant pool.<br>方法区：对于每个加载的类，它存储了方法代码和符号表（例如，对字段或方法的引用）。和称为常量池的常量。<br><img src="/2019/05/17/java-bytecode/method_area.png" title="method area"></p>
<p>A JVM stack is composed of frames, each pushed onto the stack when a method is invoked and<br>popped from the stack when the method completes (either by returning normally or by throwing an exception).<br>JVM 栈由栈帧组成，每个栈帧在方法调用时被压入栈，方法完成时从栈顶弹出（通过正常返回或抛出异常）。</p>
<p>Each frame further consists of:<br>每个栈帧还包括：</p>
<ul>
<li><p>An array of local variables, indexed from 0 to its length minus 1.<br>The length is computed by the compiler.<br>A local variable can hold a value of any type, except long and double values, which occupy two local variables.<br>局部变量的数组，索引从0 到长度减1，长度是由编译器计算。<br>局部变量可以保存任意类型的值，long 和 double 类型的值除外，它们占用两个局部变量。</p>
</li>
<li><p>An operand stack used to store intermediate values that would act as operands for instructions,<br>or to push arguments to method invocations.<br>一个操作数栈用于存储中间值，该中间值将充当指令的操作数，或者压入参数到方法调用。</p>
<img src="/2019/05/17/java-bytecode/stack_frame_zoom.png" title="stack frame">
</li>
</ul>
<h4 id="Bytecode-Explored"><a href="#Bytecode-Explored" class="headerlink" title="Bytecode Explored"></a>Bytecode Explored</h4><h4 id="探索字节码"><a href="#探索字节码" class="headerlink" title="探索字节码"></a>探索字节码</h4><p>With an idea about the internals of a JVM, we can look at some basic bytecode example generated from sample code.<br>Each method in a Java class file has a code segment that consists of a sequence of instructions,<br>each having the following format:<br>了解 JVM 的内部结构，我们可以看一下从示例代码生成的一些基本字节码示例。<br>Java class文件中的每个方法都有一个由一系列指令组成的代码片段，每个都有以下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcode (1 byte)      operand1 (optional)      operand2 (optional)      ...</span><br></pre></td></tr></table></figure></p>
<p>That is an instruction that consists of one-byte opcode and zero or more operands that contain the data to operate.<br>这是由一个字节的操作码和零个或多个操作数组成的一个指令，</p>
<p>Within the stack frame of the currently executing method, an instruction can push or pop values onto the operand stack,<br>and it can potentially load or store values in the array local variables. Let’s look at a simple example:<br>在当前正在执行的方法的栈帧内部，一个指令可以压入或弹出值到一个操作数栈，并且它可以在数组局部变量中加载或存储值。<br>让我们看一个简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In order to print the resulting bytecode in the compiled class (assuming it is in a file Test.class),<br>we can run the <code>javap</code> tool:<br>为了在编译的类中打印生成的字节码（假设它在一个Test.class文件中），我们可以运行javap 工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Test.class</span><br></pre></td></tr></table></figure></p>
<p>And we get:<br>然后我们得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=4, args_size=1</span><br><span class="line">0: iconst_1</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_2</span><br><span class="line">3: istore_2</span><br><span class="line">4: iload_1</span><br><span class="line">5: iload_2</span><br><span class="line">6: iadd</span><br><span class="line">7: istore_3</span><br><span class="line">8: return</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>We can see the method signature for the main method,<br>a descriptor that indicates that the method takes an array of Strings ([Ljava/lang/String; ),<br> and has a void return type (V ).<br> A set of flags follow that describe the method as public (ACC_PUBLIC) and static (ACC_STATIC).<br>我们可以看到主方法的方法签名，一个描述符表示该方法使用字符串数组([Ljava/lang/String; )，并且具有空返回值类型（V）。<br>下面的一组flags描述了方法是公开的(ACC_PUBLIC) 并且是静态的 (ACC_STATIC)。</p>
<p>The most important part is the Code attribute,<br>最重要的部分是代码属性，<br>which contains the instructions for the method along with information<br>such as the maximum depth of the operand stack (2 in this case),<br>and the number of local variables allocated in the frame for this method (4 in this case).<br>其中包含方法说明和信息，例如操作数栈的最大深度（在本例中为2），以及此方法在栈帧中分配的局部变量数（在本例中为4）。</p>
<p>All local variables are referenced in the above instructions except the first one (at index 0),<br>which holds the reference to the args argument.<br>The other 3 local variables correspond to variables a, b and c in the source code.<br>除了第一个（索引0）之外，上述指令中引用了所有的局部变量，它保存了对args参数的引用。<br>其他3个局部变量对应源码中的变量 a, b 和c。</p>
<p>The instructions from address 0 to 8 will do the following:<br>从地址0到8的指令将执行以下操作：</p>
<p>iconst_1: Push the integer constant 1 onto the operand stack.<br>iconst_1：将整型常量1压入到操作数栈。<br><img src="/2019/05/17/java-bytecode/iconst_12.png" title="iconst_1"></p>
<p>istore_1: Pop the top operand (an int value) and store it in local variable at index 1, which corresponds to variable a.<br>istore_1：弹出顶部操作数（一个整型值）并将其存储在索引1的局部变量中，该变量对应于变量a。<br><img src="/2019/05/17/java-bytecode/istore_11.png" title="istore_1"></p>
<p>iconst_2: Push the integer constant 2 onto the operand stack.<br>iconst_2: 将整型常量2压入到操作数栈。<br><img src="/2019/05/17/java-bytecode/iconst_2.png" title="iconst_2"></p>
<p>istore_2: Pop the top operand int value and store it in local variable at index 2, which corresponds to variable b.<br>istore_2：弹出顶部操作数整型值，并将其存储在索引2的局部变量中，该变量对应于变量b。<br><img src="/2019/05/17/java-bytecode/istore_2.png" title="istore_2"></p>
<p>iload_1: Load the int value from local variable at index 1 and push it onto the operand stack.<br>iload_1: 从索引1的局部变量加载整型值，并且将它压入操作数栈。<br><img src="/2019/05/17/java-bytecode/iload_1.png" title="iload_1"></p>
<p>iload_2: Load the int value from the local variable at index 2 and push it onto the operand stack.<br>iload_2: 从索引2的局部变量加载整型值，并且将它压入操作数栈。<br><img src="/2019/05/17/java-bytecode/iload_2.png" title="iload_2"></p>
<p>iadd: Pop the top two int values from the operand stack, add them, and push the result back onto the operand stack.<br>iadd: 从操作数栈顶部弹出两个整型值，将它们相加，并且将结果压回到操作数栈。<br><img src="/2019/05/17/java-bytecode/iadd.png" title="iadd"></p>
<p>istore_3: Pop the top operand int value and store it in local variable at index 3, which corresponds to variable c.<br>istore_3: 弹出操作数顶部的整型值，并将其存储在索引3的局部变量中，该变量对应于变量c。<br><img src="/2019/05/17/java-bytecode/istore_3.png" title="istore_3"></p>
<p>return: Return from the void method.<br>return: 从void 方法返回。</p>
<p>Each of the above instructions consists of only an opcode, which dictates exactly the operation to be executed by the JVM.<br>上面的每个指令仅由一个操作码组成，它精确地指示JVM要执行的操作。</p>
<h4 id="Method-Invocations"><a href="#Method-Invocations" class="headerlink" title="Method Invocations"></a>Method Invocations</h4><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>In the above example, there is only one method, the main method.<br>Let’s assume that we need to a more elaborate computation for the value of variable c,<br>and we decide to place that in a new method called calc:<br>在上面示例中只有一个方法，主方法。<br>让我们假设我们需要对变量c的值进行一个更复杂的计算，我们决定将其放在一个名为calc的新方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = calc(a, b);</span><br><span class="line">&#125;</span><br><span class="line">static int calc(int a, int b) &#123;</span><br><span class="line">    return (int) Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Let’s see the resulting bytecode:<br>让我们看看生成的字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=4, args_size=1</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_2</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_1</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: invokestatic  #2         // Method calc:(II)I</span><br><span class="line">       9: istore_3</span><br><span class="line">      10: return</span><br><span class="line">static int calc(int, int);</span><br><span class="line">  descriptor: (II)I</span><br><span class="line">  flags: (0x0008) ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=6, locals=2, args_size=2</span><br><span class="line">       0: iload_0</span><br><span class="line">       1: i2d</span><br><span class="line">       2: ldc2_w        #3         // double 2.0d</span><br><span class="line">       5: invokestatic  #5         // Method java/lang/Math.pow:(DD)D</span><br><span class="line">       8: iload_1</span><br><span class="line">       9: i2d</span><br><span class="line">      10: ldc2_w        #3         // double 2.0d</span><br><span class="line">      13: invokestatic  #5         // Method java/lang/Math.pow:(DD)D</span><br><span class="line">      16: dadd</span><br><span class="line">      17: invokestatic  #6         // Method java/lang/Math.sqrt:(D)D</span><br><span class="line">      20: d2i</span><br><span class="line">      21: ireturn</span><br></pre></td></tr></table></figure>
<p>The only difference in the main method code is that instead of having the iadd instruction,<br>we now an invokestatic instruction, which simply invokes the static method calc.<br>The key thing to note is that the operand stack contained the two arguments that are passed to the method calc.<br>In other words, the calling method prepares all arguments of the to-be-called method by pushing them<br>onto the operand stack in the correct order.<br>invokestatic (or a similar invoke instruction, as will be seen later) will subsequently pop these arguments,<br>and a new frame is created for the invoked method where the arguments are placed in its local variable array.<br>在主方法代码中唯一不同的是，不是使用iadd 命令，我们现在是一个 invokestatic 命令，它只是调用静态方法calc。<br>关键需要注意的是，操作数栈包含传递给方法calc的两个参数。<br>换句话说，调用方法准备被调用方法的所有参数，通过以正确的顺序压入它们到操作数栈。<br>invokestatic（或者类似的调用命令，稍后将会看到）将随后弹出这些参数，<br>并为调用的方法创建一个新的栈帧，其中参数放在其局部变量数组中。</p>
<p>We also notice that the invokestatic instruction occupies 3 bytes by looking at the address, which jumped from 6 to 9.<br>This is because, unlike all instructions seen so far,<br>invokestatic includes two additional bytes to construct the reference to the method to be invoked (in addition to the opcode).<br>The reference is shown by javap as #2, which is a symbolic reference to the calc method,<br>which is resolved from the constant pool described earlier.<br>我们也注意到通过查看地址 invokestatic 命令占用3个字节，地址从6跳到9。<br>这是因为不像目前看到的所有指令，invokestatic 指令包含两个附加的字节来构造调用方法的引用（除了操作码）。<br>该引用由javap 显示为2，它是calc方法的符号引用，这是从前面描述的常量池中解析出来的。</p>
<p>The other new information is obviously the code for the calc method itself.<br>It first loads the first integer argument onto the operand stack (iload_0).<br>The next instruction, i2d, converts it to a double by applying widening conversion.<br>The resulting double replaces the top of the operand stack.<br>其他新信息显然是calc方法本身的代码。<br>它首先加载第一个整型参数到操作数栈（iload_0）。<br>下一个指令i2d，通过应用扩展转换将其转换为double。<br>结果double 替换操作数栈顶。</p>
<p>The next instruction pushes a double constant 2.0d  (taken from the constant pool) onto the operand stack.<br>Then the static Math.pow method is invoked with the two operand values prepared so far<br>(the first argument to calc and the constant 2.0d).<br>When the Math.pow method returns, its result will be stored on the operand stack of its invoker.<br>This can be illustrated below.<br>下一个指令压入一个double类型的常量2.0d（取自常量池）到操作数栈。<br>然后使用到目前为止准备的两个操作数值调用静态方法Math.pow（calc方法的第一个参数和常量2.0d)。<br>当Math.pow 方法返回时，其结果存储在其调用者的操作数栈。这可以在下面说明。<br><img src="/2019/05/17/java-bytecode/math_pow2.png" title="math pow"></p>
<p>The same procedure is applied to compute Math.pow(b, 2):<br>计算Math.pow(b, 2)是相似的过程：<br><img src="/2019/05/17/java-bytecode/math_pow21.png" title="math pow"></p>
<p>The next instruction, dadd, pops the top two intermediate results, adds them, and pushes the sum back to the top.<br>Finally, invokestatic invokes Math.sqrt on the resulting sum,<br>and the result is cast from double to int using narrowing conversion (d2i).<br>The resulting int is returned to the main method, which stores it back to c (istore_3).<br>下一个指令dadd 弹出栈顶的两个中间结果，相加，将相加结果压回栈顶。<br>最后，invokestatic 调用Math.sqrt<br>并且使用强制转换（d2i）将结果从double 转换成int。<br>int类型的结果被返回到main方法，存储到变量c（istore_3）。</p>
<h4 id="Instance-Creations"><a href="#Instance-Creations" class="headerlink" title="Instance Creations"></a>Instance Creations</h4><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>Let’s modify the example and introduce a class Point to encapsulate XY coordinates.<br>让我们修改示例并引入Point类来封装XY坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point a = new Point(1, 1);</span><br><span class="line">        Point b = new Point(5, 3);</span><br><span class="line">        int c = a.area(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Point &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    public int area(Point b) &#123;</span><br><span class="line">        int length = Math.abs(b.y - this.y);</span><br><span class="line">        int width = Math.abs(b.x - this.x);</span><br><span class="line">        return length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The compiled bytecode for the main method is shown below:<br>main方法的编译字节码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=4, locals=4, args_size=1</span><br><span class="line">       0: new           #2       // class test/Point</span><br><span class="line">       3: dup</span><br><span class="line">       4: iconst_1</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: invokespecial #3       // Method test/Point.&quot;&lt;init&gt;&quot;:(II)V</span><br><span class="line">       9: astore_1</span><br><span class="line">      10: new           #2       // class test/Point</span><br><span class="line">      13: dup</span><br><span class="line">      14: iconst_5</span><br><span class="line">      15: iconst_3</span><br><span class="line">      16: invokespecial #3       // Method test/Point.&quot;&lt;init&gt;&quot;:(II)V</span><br><span class="line">      19: astore_2</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: invokevirtual #4       // Method test/Point.area:(Ltest/Point;)I</span><br><span class="line">      25: istore_3</span><br><span class="line">      26: return</span><br></pre></td></tr></table></figure></p>
<p>The new instructions encountereted here are new , dup, and invokespecial.<br>这里遇到的新指令是new, dup 和 invokespecial。</p>
<p>Similar to the new operator in the programming language,<br>the new instruction creates an object of the type specified in the operand passed to it<br> (which is a symbolic reference to the class Point).<br>Memory for the object is allocated on the heap, and a reference to the object is pushed on the operand stack.<br>与编程语言中的new 运算符类似，new 指令创建一个传递给它的操作数中指定类型的对象（这是Point类的符号引用）。<br>对象的内存在堆上分配，对象的引用是被压入操作数栈。</p>
<p>The dup instruction duplicates the top operand stack value,<br>which means that now we have two references the Point object on the top of the stack.<br>dup 指令复制操作数栈顶值，这意味着现在我们在栈顶有两个引用Point对象。</p>
<p>The next three instructions push the arguments of the constructor<br>(used to initialize the object) onto the operand stack,<br>and then invoke a special initialization method, which corresponds with the constructor.<br>接下来三个指令将构造方法（用于初始化对象）的参数压入到操作数栈上，然后调用一个特殊的初始化方法，该方法与构造方法对应。</p>
<p>The next method is where the fields x and y will get initialized.<br>After the method is finished, the top three operand stack values are consumed,<br>and what remains is the original reference to the created object (which is, by now, successfully initialized).<br>下一个方法是属性x 和 y 将得到初始化，方法完成后，顶部三个操作数值被消费，<br>剩下来的是对创建对象的原始引用（这时初始化成功）。<br><img src="/2019/05/17/java-bytecode/init.png" title="init"></p>
<p>Next, astore_1 pops that Point reference and assigns it to the local variable at index 1<br>(the a in astore_1 indicates this is a reference value).<br>接下来，astore_1 弹出Point引用并将其分配给索引为1的局部变量（astore_1中的a表示这是引用值）。<br><img src="/2019/05/17/java-bytecode/init_store.png" title="init_store"></p>
<p>The same procedure is repeated for creating and initializing the second Point instance,<br> which is assigned to variable b.<br>重复相似的过程来创建和初始化第二个Point实例，分配给变量b。<br><img src="/2019/05/17/java-bytecode/init2.png" title="init"><br><img src="/2019/05/17/java-bytecode/init_store2.png" title="init_store"></p>
<p>The last step loads the references to the two Point objects from local variables at indexes 1 and 2<br>(using aload_1 and aload_2 respectively), and invokes the area method using invokevirtual,<br>which handles dispatching the call to the appropriate method based on the actual type of the object.<br>最后一步从局部变量的索引1和2中加载对两个Point对象的引用（分别使用aload_1 和 aload_2指令），<br>并且使用invokevirtual 指令调用area方法，它处理根据对象的实际类型将调用到适当的方法。</p>
<p>For example, if the variable a contained an instance of type SpecialPoint that extends Point,<br>and the subtype overrides the area method, then the overriden method is invoked.<br>In this case, there is no subclass, and hence only one area method is available.<br>例如，如果变量a 包含一个继承了Point的SpecialPoint类型的实例，并且子类型重写了area方法，然后重写的方法被调用。<br>在这个例子中，没有子类，因此只有一个area方法是可用的。<br><img src="/2019/05/17/java-bytecode/area2.png"></p>
<p>Note that even though the area method accepts one argument,<br>there are two Point references on the top of the stack.<br>注意，即使area方法接收一个参数，在栈顶有两个Point引用。</p>
<p>The first one (pointA, which comes from variable a) is actually the instance<br>on which the method is invoked (otherwise referred to as this in the programming language),<br>and it will be passed in the first local variable of the new frame for the area method.<br>The other operand value (pointB) is the argument to the area method.<br>第一个（PointA 来自变量a）是调用方法的实际实例（在编程语言中称为this），<br>它将在area方法的新帧的第一个局部变量中传递。另一个操作数值（pointB）是area方法的参数。</p>
<h4 id="The-Other-Way-Around"><a href="#The-Other-Way-Around" class="headerlink" title="The Other Way Around"></a>The Other Way Around</h4><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>You don’t need to master the understanding of each instruction<br>and the exact flow of execution to gain an idea about what the program does based on the bytecode at hand.<br>For example, in my case, I wanted to check if the code employed a Java stream to read a file,<br>and whether the stream was properly closed.<br>Now given the following bytecode, it is relatively easy to determine that indeed a stream is used<br>and most likely it is being closed as part of a try-with-resources statement.<br>你不需要掌握每个指令的意义，以及确切的执行流程，以便于根据字节码了解程序的功能。<br>例如，在我的情况下，我想检查代码是否使用Java流读取文件， 以及流是否正确关闭。<br>现在给出如下的字节码，它是相对容易的确定确实使用了流，并且很可能它是作为try-with-resources的一部分而被关闭的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]) throws java.lang.Exception;</span><br><span class="line"> descriptor: ([Ljava/lang/String;)V</span><br><span class="line"> flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line"> Code:</span><br><span class="line">   stack=2, locals=8, args_size=1</span><br><span class="line">      0: ldc           #2                  // class test/Test</span><br><span class="line">      2: ldc           #3                  // String input.txt</span><br><span class="line">      4: invokevirtual #4                  // Method java/lang/Class.getResource:(Ljava/lang/String;)Ljava/net/URL;</span><br><span class="line">      7: invokevirtual #5                  // Method java/net/URL.toURI:()Ljava/net/URI;</span><br><span class="line">     10: invokestatic  #6                  // Method java/nio/file/Paths.get:(Ljava/net/URI;)Ljava/nio/file/Path;</span><br><span class="line">     13: astore_1</span><br><span class="line">     14: new           #7                  // class java/lang/StringBuilder</span><br><span class="line">     17: dup</span><br><span class="line">     18: invokespecial #8                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     21: astore_2</span><br><span class="line">     22: aload_1</span><br><span class="line">     23: invokestatic  #9                  // Method java/nio/file/Files.lines:(Ljava/nio/file/Path;)Ljava/util/stream/Stream;</span><br><span class="line">     26: astore_3</span><br><span class="line">     27: aconst_null</span><br><span class="line">     28: astore        4</span><br><span class="line">     30: aload_3</span><br><span class="line">     31: aload_2</span><br><span class="line">     32: invokedynamic #10,  0             // InvokeDynamic #0:accept:(Ljava/lang/StringBuilder;)Ljava/util/function/Consumer;</span><br><span class="line">     37: invokeinterface #11,  2           // InterfaceMethod java/util/stream/Stream.forEach:(Ljava/util/function/Consumer;)V</span><br><span class="line">     42: aload_3</span><br><span class="line">     43: ifnull        131</span><br><span class="line">     46: aload         4</span><br><span class="line">     48: ifnull        72</span><br><span class="line">     51: aload_3</span><br><span class="line">     52: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">     57: goto          131</span><br><span class="line">     60: astore        5</span><br><span class="line">     62: aload         4</span><br><span class="line">     64: aload         5</span><br><span class="line">     66: invokevirtual #14                 // Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V</span><br><span class="line">     69: goto          131</span><br><span class="line">     72: aload_3</span><br><span class="line">     73: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">     78: goto          131</span><br><span class="line">     81: astore        5</span><br><span class="line">     83: aload         5</span><br><span class="line">     85: astore        4</span><br><span class="line">     87: aload         5</span><br><span class="line">     89: athrow</span><br><span class="line">     90: astore        6</span><br><span class="line">     92: aload_3</span><br><span class="line">     93: ifnull        128</span><br><span class="line">     96: aload         4</span><br><span class="line">     98: ifnull        122</span><br><span class="line">    101: aload_3</span><br><span class="line">    102: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">    107: goto          128</span><br><span class="line">    110: astore        7</span><br><span class="line">    112: aload         4</span><br><span class="line">    114: aload         7</span><br><span class="line">    116: invokevirtual #14                 // Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V</span><br><span class="line">    119: goto          128</span><br><span class="line">    122: aload_3</span><br><span class="line">    123: invokeinterface #12,  1           // InterfaceMethod java/util/stream/Stream.close:()V</span><br><span class="line">    128: aload         6</span><br><span class="line">    130: athrow</span><br><span class="line">    131: getstatic     #15                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    134: aload_2</span><br><span class="line">    135: invokevirtual #16                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    138: invokevirtual #17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    141: return</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>We see occurrences of java/util/stream/Stream where forEach is called,<br>preceded by a call to InvokeDynamic with a reference to a Consumer.<br>我们看到java/util/stream/Stream的出现在forEach被调用的地方，之前调用InvokeDynamic 并引用Consumer。</p>
<p>And then we see a chunk of bytecode that calls Stream.close along with branches that call Throwable.addSuppressed.<br>然后我们看到大块字节码调用Stream.close 以及调用Throwable.addSuppressed 的分支。</p>
<p>This is the basic code that gets generated by the compiler for a try-with-resources statement.<br>这是编译器为try-with-resources语句生成的基本代码。</p>
<p>Here’s the original source for completeness:<br>以下是完整的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Path path = Paths.get(Test.class.getResource(&quot;input.txt&quot;).toURI());</span><br><span class="line">    StringBuilder data = new StringBuilder();</span><br><span class="line">    try(Stream lines = Files.lines(path)) &#123;</span><br><span class="line">        lines.forEach(line -&gt; data.append(line).append(&quot;\n&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(data.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Thanks to the simplicity of the bytecode instruction set<br>and the near absence of compiler optimizations when generating its instructions,<br>disassembling class files could be one way to examine changes into<br>your application code without having the source, if that ever becomes a need.<br>由于字节码指令集的简化，并且在生成其指令时几乎没有编译器优化，<br>在你的应用程序代码没有源码，如果需要的话，反编译类文件可能是检查更改的一种方法。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="geekymv 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/26/data-structure/" rel="next" title="data-structure">
                <i class="fa fa-chevron-left"></i> data-structure
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/21/insight/" rel="prev" title="insight">
                insight <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">geekymv</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM数据类型"><span class="nav-number">1.</span> <span class="nav-text">JVM数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于栈的架构"><span class="nav-number">2.</span> <span class="nav-text">基于栈的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bytecode-Explored"><span class="nav-number">3.</span> <span class="nav-text">Bytecode Explored</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#探索字节码"><span class="nav-number">4.</span> <span class="nav-text">探索字节码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-Invocations"><span class="nav-number">5.</span> <span class="nav-text">Method Invocations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法调用"><span class="nav-number">6.</span> <span class="nav-text">方法调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Instance-Creations"><span class="nav-number">7.</span> <span class="nav-text">Instance Creations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建实例"><span class="nav-number">8.</span> <span class="nav-text">创建实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Other-Way-Around"><span class="nav-number">9.</span> <span class="nav-text">The Other Way Around</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他方式"><span class="nav-number">10.</span> <span class="nav-text">其他方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Conclusion"><span class="nav-number">11.</span> <span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结论"><span class="nav-number">12.</span> <span class="nav-text">结论</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">geekymv</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>






        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '7ba92bf62d54c647c905',
        clientSecret: '7ae2dbfd950a779266974e470d2d69d1f37155a2',
        repo: 'blog',
        owner: 'geekymv',
        admin: ['geekymv'],
        id: location.pathname,
        labels: ['Gitalk'],
        perPage: 15,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
