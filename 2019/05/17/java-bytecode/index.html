<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="阅读原文Reading compiled Java bytecode can be tedious, even for experienced Java developers.即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。 Why do we need to know about such low-level stuff in the first place?首先">
<meta property="og:type" content="article">
<meta property="og:title" content="introduction-to-java-bytecode">
<meta property="og:url" content="http://yoursite.com/2019/05/17/java-bytecode/index.html">
<meta property="og:site_name" content="geekymv">
<meta property="og:description" content="阅读原文Reading compiled Java bytecode can be tedious, even for experienced Java developers.即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。 Why do we need to know about such low-level stuff in the first place?首先">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/jvm_stacks.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/heap.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/method_area.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/stack_frame_zoom.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iconst_12.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/istore_11.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iconst_2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/istore_2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iload_1.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iload_2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/iadd.png">
<meta property="og:image" content="http://yoursite.com/2019/05/17/java-bytecode/istore_3.png">
<meta property="og:updated_time" content="2019-05-18T16:29:19.677Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="introduction-to-java-bytecode">
<meta name="twitter:description" content="阅读原文Reading compiled Java bytecode can be tedious, even for experienced Java developers.即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。 Why do we need to know about such low-level stuff in the first place?首先">
<meta name="twitter:image" content="http://yoursite.com/2019/05/17/java-bytecode/jvm_stacks.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/17/java-bytecode/">





  <title>introduction-to-java-bytecode | geekymv</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">geekymv</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/java-bytecode/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geekymv">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geekymv">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">introduction-to-java-bytecode</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T14:14:14+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://dzone.com/articles/introduction-to-java-bytecode" target="_blank" rel="noopener">阅读原文</a><br>Reading compiled Java bytecode can be tedious, even for experienced Java developers.<br>即使对于经验丰富的Java开发人员来说，阅读编译后的Java字节码也可能很乏味。</p>
<p>Why do we need to know about such low-level stuff in the first place?<br>首先，我们为什么需要知道这些底层的东西呢？</p>
<p>Here is a simple scenario that happened to me last week:<br>下面是上周发生在我身上的一个简单场景：</p>
<p>I had made some code changes on my machine a long time ago, compiled a JAR,<br>很久以前，我在自己的机器上修改了一些代码，编译成一个JAR包，</p>
<p>and deployed it on a server to test a potential fix for a performance issue.<br>并且部署在一台服务器上以测试性能问题的潜在修复。</p>
<p>Unfortunately, the code was never checked into a version control system,<br>不幸的是，代码没有加入版本控制系统，</p>
<p>and for whatever reason, the local changes were deleted without a trace.<br>并且由于一些原因，本地的修改被删除的毫无踪迹。</p>
<p>After a couple of months, I needed those changes in source form again (which took quite an effort to come up with),<br>几个月后，我再一次需要这些修改的源码（这需要付出很大的努力），<br>but I could not find them!<br>但是我没有找到它们！</p>
<p>Luckily the compiled code still existed on that remote server.<br>幸运的是编译后的代码依然存在远程服务器上。</p>
<p>So with a sigh of relief, I fetched the JAR again and opened it using a decompiler editor…<br>于是松了一口气，我再一次获取到JAR包并且使用反编译编辑器打开它…</p>
<p>Only one problem: The decompiler GUI is not a flawless tool, and out of the many classes in that JAR,<br>唯一问题：反编译器GUI不是一个完美的工具，而且在这个JAR中有很多类，</p>
<p>for some reason, only the specific class I was looking to decompile caused a bug in the UI whenever I opened it, and the decompiler to crash!<br>由于某种原因，无论什么时候，我用反编译工具打开要查看的特定类就会引起一个UI bug，反编译器会崩溃！</p>
<p>Desperate times call for desperate measures. Fortunately, I was familiar with raw bytecode,<br>绝望的时候需要孤注一掷的对策。幸运的是，我熟悉原生字节码，</p>
<p>and I’d rather take some time manually decompiling some pieces of the code rather than work through the changes and testing them again.<br>并且，我宁愿花费一些时间手工反编译代码也不愿对更改进行重新测试。</p>
<p>Since I still remembered at least where to look in the code,<br>因为我至少还记得在哪里查看代码，</p>
<p>reading bytecode helped me pinpoint the exact changes and construct them back in source form.<br> (I made sure to learn from my mistake and preserve them this time!)<br>阅读字节码帮助我精确的定位实际改变的地方，并且使用源码的形式构造它们（我一定要从我的错误中吸取教训，这次一定要记住！）。</p>
<p>The nice thing about bytecode is that you learn its syntax once, then it applies on all Java supported platforms —<br> 字节码的好处是你一旦学习它的语法，它可以应用于所欲Java支持的平台 - </p>
<p>because it is an intermediate representation of the code, and not the actual executable code for the underlying CPU.<br>因为它表示一个中间代码，不是实际在CPU上执行的代码。</p>
<p>Moreover, bytecode is simpler than native machine code because the JVM architecture is rather simple,<br>另外，字节码比本地机器码简单因为Java虚拟机架构相当简单。</p>
<p>hence simplifying the instruction set. Yet another nice thing is that all instructions in this set are fully documented by Oracle.<br>因此简化了指令集，然而，另一件好事是指令集中所有指令完全由Oracle提供。</p>
<p>Before learning about the bytecode instruction set though, let’s get familiar with a few things about the JVM that are needed as a prerequisite.<br>学习字节码指令集之前， 让我们先熟悉一下JVM的基础，作为学习指令集的前提条件。</p>
<p>JVM Data Types</p>
<h4 id="JVM数据类型"><a href="#JVM数据类型" class="headerlink" title="JVM数据类型"></a>JVM数据类型</h4><p>Java is statically typed, which affects the design of the bytecode instructions such that an instruction expects itself to operate on values of specific types.<br>Java是静态类型的，这影响了指令字节码的设计，使得一个指令期望自己去操作指定类型的值。</p>
<p>For example, there are several add instructions to add two numbers: iadd, ladd, fadd, dadd.<br>例如，有几个两个数的相加指令：iadd, ladd, fadd, dadd。<br>They expect operands of type, respectively, int, long, float, and double.<br>它们期望操作的类型分别是int, long, float, 和 double。</p>
<p>The majority of bytecode has this characteristic of having different forms of the same functionality depending on the operand types.<br>根据操作类型不同，相同的功能有不同的形式，大多数字节码具有的特征。</p>
<p>The data types defined by the JVM are:<br>JVM定义的数据类型：</p>
<p>Primitive types:<br>原生类型：</p>
<p>Numeric types: byte (8-bit 2’s complement), short (16-bit 2’s complement), int (32-bit 2’s complement), long (64-bit 2’s complement), char (16-bit unsigned Unicode), float (32-bit IEEE 754 single precision FP), double (64-bit IEEE 754 double precision FP)<br>数字类型：byte(8bit), short(16bit), int(32bit), long(64bit), char(16bit), float(32bit), double(64bit)</p>
<p>boolean type<br>布尔类型</p>
<p>returnAddress: pointer to instruction<br>返回地址：指向指令</p>
<p>Reference types:<br>引用类型</p>
<p>Class types<br>类类型</p>
<p>Array types<br>数组类型</p>
<p>Interface types<br>接口类型</p>
<p>The boolean type has limited support in bytecode.<br>字节码对布尔类型的支持有限制。<br>For example, there are no instructions that directly operate on boolean values.<br>例如，没有指令直接操作布尔类型。</p>
<p>Boolean values are instead converted to int by the compiler and the corresponding int instruction is used.<br>编译器将boolean值转换为int，并使用相应的int指令。</p>
<p>Java developers should be familiar with all of the above types, except returnAddress, which has no equivalent programming language type.<br>Java开发人员应该熟悉上述所有类型，除了returnAddress类型，它没有等价的编程语言类型。</p>
<p>Stack-Based Architecture</p>
<h4 id="基于栈的架构"><a href="#基于栈的架构" class="headerlink" title="基于栈的架构"></a>基于栈的架构</h4><p>The simplicity of the bytecode instruction set is largely due to Sun having designed a stack-based VM architecture, as opposed to a register-based one.<br>字节码指令集的简单性很大程度上归功于Sun设计了基于栈的VM 架构，而不是基于寄存器的架构。</p>
<p>There are various memory components used by a JVM process, but only the JVM stacks need to be examined in detail to essentially be able to follow bytecode instructions:<br>JVM 进程使用了各种内存组件，但是只需要详细检查JVM 栈，以便能够遵循字节码指令：</p>
<p>PC register: for each thread running in a Java program, a PC register stores the address of the current instruction.<br>程序计数器：对于每个运行在Java进程中的线程，PC 寄存器存储当前指令的地址。</p>
<p>JVM stack: for each thread, a stack is allocated where local variables, method arguments,<br>and return values are stored. Here is an illustration showing stacks for 3 threads.<br>JVM 栈：对于每个线程，被申请的栈用于存储本地变量，方法参数，返回值。下面是显示3个线程的堆栈图。</p>
<img src="/2019/05/17/java-bytecode/jvm_stacks.png" title="jvm stack">
<p>Heap: memory shared by all threads and storing objects (class instances and arrays).<br>堆：堆内存被所有线程共享，用来存储对象（类实例和数组）。<br>Object deallocation is managed by a garbage collector.<br>对象的释放由垃圾收集器管理。</p>
<img src="/2019/05/17/java-bytecode/heap.png" title="heap">
<p>Method area: for each loaded class, it stores the code of methods and a table of symbols<br>(e.g. references to fields or methods) and constants known as the constant pool.<br>方法区：对于每个加载的类，它存储了方法代码和符号表（例如，对字段或方法的引用）。和称为常量池的常量。<br><img src="/2019/05/17/java-bytecode/method_area.png" title="method area"></p>
<p>A JVM stack is composed of frames, each pushed onto the stack when a method is invoked and<br>popped from the stack when the method completes (either by returning normally or by throwing an exception).<br>JVM 栈由栈帧组成，每个栈帧在方法调用时被压入栈，方法完成时从栈顶弹出（通过正常返回或抛出异常）。</p>
<p>Each frame further consists of:<br>每个栈帧还包括：<br>1.An array of local variables, indexed from 0 to its length minus 1.<br>The length is computed by the compiler.<br>A local variable can hold a value of any type, except long and double values, which occupy two local variables.<br>局部变量的数组，索引从0 到长度减1，长度是由编译器计算。<br>局部变量可以保存任意类型的值，long 和 double 类型的值除外，它们占用两个局部变量。</p>
<p>2.An operand stack used to store intermediate values that would act as operands for instructions,<br>or to push arguments to method invocations.<br>一个操作数栈用于存储中间值，该中间值将充当指令的操作数，或者压入参数到方法调用。<br><img src="/2019/05/17/java-bytecode/stack_frame_zoom.png" title="stack frame"></p>
<h4 id="Bytecode-Explored"><a href="#Bytecode-Explored" class="headerlink" title="Bytecode Explored"></a>Bytecode Explored</h4><h4 id="探索字节码"><a href="#探索字节码" class="headerlink" title="探索字节码"></a>探索字节码</h4><p>With an idea about the internals of a JVM, we can look at some basic bytecode example generated from sample code.<br>Each method in a Java class file has a code segment that consists of a sequence of instructions,<br>each having the following format:<br>了解 JVM 的内部结构，我们可以看一下从示例代码生成的一些基本字节码示例。<br>Java class文件中的每个方法都有一个由一系列指令组成的代码片段，每个都有以下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcode (1 byte)      operand1 (optional)      operand2 (optional)      ...</span><br></pre></td></tr></table></figure></p>
<p>That is an instruction that consists of one-byte opcode and zero or more operands that contain the data to operate.<br>这是由一个字节的操作码和零个或多个操作数组成的一个指令，</p>
<p>Within the stack frame of the currently executing method, an instruction can push or pop values onto the operand stack,<br>and it can potentially load or store values in the array local variables. Let’s look at a simple example:<br>在当前正在执行的方法的栈帧内部，一个指令可以压入或弹出值到一个操作数栈，并且它可以在数组局部变量中加载或存储值。<br>让我们看一个简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In order to print the resulting bytecode in the compiled class (assuming it is in a file Test.class),<br>we can run the <code>javap</code> tool:<br>为了在编译的类中打印生成的字节码（假设它在一个Test.class文件中），我们可以运行javap 工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Test.class</span><br></pre></td></tr></table></figure></p>
<p>And we get:<br>然后我们得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=4, args_size=1</span><br><span class="line">0: iconst_1</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_2</span><br><span class="line">3: istore_2</span><br><span class="line">4: iload_1</span><br><span class="line">5: iload_2</span><br><span class="line">6: iadd</span><br><span class="line">7: istore_3</span><br><span class="line">8: return</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>We can see the method signature for the main method,<br>a descriptor that indicates that the method takes an array of Strings ([Ljava/lang/String; ),<br> and has a void return type (V ).<br> A set of flags follow that describe the method as public (ACC_PUBLIC) and static (ACC_STATIC).<br>我们可以看到主方法的方法签名，一个描述符表示该方法使用字符串数组([Ljava/lang/String; )，并且具有空返回值类型（V）。<br>下面的一组flags描述了方法是公开的(ACC_PUBLIC) 并且是静态的 (ACC_STATIC)。</p>
<p>The most important part is the Code attribute,<br>最重要的部分是代码属性，<br>which contains the instructions for the method along with information<br>such as the maximum depth of the operand stack (2 in this case),<br>and the number of local variables allocated in the frame for this method (4 in this case).<br>其中包含方法说明和信息，例如操作数栈的最大深度（在本例中为2），以及此方法在栈帧中分配的局部变量数（在本例中为4）。</p>
<p>All local variables are referenced in the above instructions except the first one (at index 0),<br>which holds the reference to the args argument.<br>The other 3 local variables correspond to variables a, b and c in the source code.<br>除了第一个（索引0）之外，上述指令中引用了所有的局部变量，它保存了对args参数的引用。<br>其他3个局部变量对应源码中的变量 a, b 和c。</p>
<p>The instructions from address 0 to 8 will do the following:<br>从地址0到8的指令将执行以下操作：</p>
<p>iconst_1: Push the integer constant 1 onto the operand stack.<br>iconst_1：将整型常量1压入到操作数栈。<br><img src="/2019/05/17/java-bytecode/iconst_12.png" title="iconst_1"></p>
<p>istore_1: Pop the top operand (an int value) and store it in local variable at index 1, which corresponds to variable a.<br>istore_1：弹出顶部操作数（一个整型值）并将其存储在索引1的局部变量中，该变量对应于变量a。<br><img src="/2019/05/17/java-bytecode/istore_11.png" title="istore_1"></p>
<p>iconst_2: Push the integer constant 2 onto the operand stack.<br>iconst_2: 将整型常量2压入到操作数栈。<br><img src="/2019/05/17/java-bytecode/iconst_2.png" title="iconst_2"></p>
<p>istore_2: Pop the top operand int value and store it in local variable at index 2, which corresponds to variable b.<br>istore_2：弹出顶部操作数整型值，并将其存储在索引2的局部变量中，该变量对应于变量b。<br><img src="/2019/05/17/java-bytecode/istore_2.png" title="istore_2"></p>
<p>iload_1: Load the int value from local variable at index 1 and push it onto the operand stack.<br>iload_1: 从索引1的局部变量加载整型值，并且将它压入操作数栈。<br><img src="/2019/05/17/java-bytecode/iload_1.png" title="iload_1"></p>
<p>iload_2: Load the int value from the local variable at index 2 and push it onto the operand stack.<br>iload_2: 从索引2的局部变量加载整型值，并且将它压入操作数栈。<br><img src="/2019/05/17/java-bytecode/iload_2.png" title="iload_2"></p>
<p>iadd: Pop the top two int values from the operand stack, add them, and push the result back onto the operand stack.<br>iadd: 从操作数栈顶部弹出两个整型值，将它们相加，并且将结果压回到操作数栈。<br><img src="/2019/05/17/java-bytecode/iadd.png" title="iadd"></p>
<p>istore_3: Pop the top operand int value and store it in local variable at index 3, which corresponds to variable c.<br>istore_3: 弹出操作数顶部的整型值，并将其存储在索引3的局部变量中，该变量对应于变量c。<br><img src="/2019/05/17/java-bytecode/istore_3.png" title="istore_3"></p>
<p>return: Return from the void method.<br>return: 从void 方法返回。</p>
<p>Each of the above instructions consists of only an opcode, which dictates exactly the operation to be executed by the JVM.<br>上面的每个指令仅由一个操作码组成，它精确地指示JVM要执行的操作。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/26/data-structure/" rel="next" title="data-structure">
                <i class="fa fa-chevron-left"></i> data-structure
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">geekymv</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM数据类型"><span class="nav-number">1.</span> <span class="nav-text">JVM数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于栈的架构"><span class="nav-number">2.</span> <span class="nav-text">基于栈的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bytecode-Explored"><span class="nav-number">3.</span> <span class="nav-text">Bytecode Explored</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#探索字节码"><span class="nav-number">4.</span> <span class="nav-text">探索字节码</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">geekymv</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>






        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
